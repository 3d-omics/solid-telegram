---
title: "3D'omics | Avian microbiome - Methods MSSM manuscript"
author:
- Antton Alberdi^[University of Copenhagen, antton.alberdi@sund.ku.dk]
- Amalia Bogri^[University of Copenhagen, amalia.bogri@sund.ku.dk]
- Carlotta Pietroni^[University of Copenhagen, carlotta.pietroni@sund.ku.dk]
- Jorge Langa^[University of Copenhagen, jorge.langa@sund.ku.dk]
date: "`r Sys.Date()`"
subtitle: Work in progress
site: bookdown::bookdown_site
documentclass: book
bibliography:
- book.bib
- packages.bib
url: "https://3d-omics.github.io/XXXX"
description: |
  Data analysis code for 3D'omics microdissection methods manuscript (MSSM)
link-citations: true
github-repo: "3d-omics/XXX"
---

```{r knitr_opts, echo=FALSE}
knitr::opts_chunk$set(
  class.source = "script-source",
  class.output = "script-output",
  comment = NA
)
```

# Introduction

This webbook contains all the code used for the analyses of the MSSM methods manuscript.

## Prepare the R environment

### Environment

To reproduce all the analyses locally, clone this repository in your computer using:

```
RStudio > New Project > Version Control > Git
```

And indicating the following git repository:

> https://github.com/3d-omics/ANMI014_chicken_LMD_methods.git

Once the R project has been created, follow the instructions and code chunks shown in this webbook.

### Libraries

The following R packages are required for the data analysis.

```{r load_libraries, warning=FALSE, comments="", message=FALSE}
# Base
library(R.utils)
library(knitr)
library(devtools)
library(tinytable)
library(broom)
library(broom.mixed)
library(rairtable)
library(jsonlite)

# For tree handling
library(ape)
library(phyloseq)
library(phytools)

# For plotting
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(ggnewscale)
library(gridExtra)
library(ggtreeExtra)
library(ggtree)
library(ggh4x)
library(jpeg)
library(patchwork)

# For statistics
library(spaa)
library(vegan)
library(Rtsne)
library(geiger)
library(hilldiv2)
library(distillR)
library(ANCOMBC)
library(lme4)
library(Hmsc)
library(psych)

# For compositional analyses
library(zCompositions)
library(compositions)

# Tidyverse libraries (load dplyr last to avoid conflicts)
library(tidyverse)
library(dplyr) # Explicitly load dplyr last
```

## Notes:
### Installation of modules
Most of the modules can be downloaded from CRAN with 'install.packages('XXX', dependencies = TRUE)'.
Four modules are from Bioconductor. 
Install with: 'install.packages('BiocManager', dependencies = TRUE)
BiocManager::install(c("phyloseq", "ggtreeExtra","ggtree","ANCOMBC"))'
Two modules are from Antton's github. 
Install with: 'install.packages('remotes', dependencies = TRUE)
remotes::install_github('anttonalberdi/hilldiv2')
remotes::install_github('anttonalberdi/distillR')'

### Airtable access:
Currently the metadata is loaded from the 3D'omics airtable. In order to access it you need your own API key (from Antton). set_airtable_api_key('XXXXX', install = TRUE)

<!--chapter:end:index.Rmd-->

# Data Import


## Bacterial reads (counts) data
Import the count tables from ERDA.
All files were produced with Reference MAG catalogue 009.
In the next version, we will fetch only one file with all the counts from all batches. And it might be a json file containing all needed tsv files.

Questions:
- MSEB0009 has a column 'undetermined'. Why? Answer: it comes from Novogene.

There are more than one columns for each sample. 
MSEB0006, MSEB0011, MSEB0012, MSEB0014, MSEB0015 - have no repetitions of samples
MSEB0009 - some samples are there twice (reaching up to .lib2)
MSEB0010 - some samples are there 6 or 7 times (reaching up to .lib6 or .lib7)
Answer: it comes from Novogene resequencing those batches multiple times.

Found it with:   
group_by(genome, sample) %>%
   count() %>%  # Get group sizes
   group_by(n) %>%  # Group by the size of each group
   summarise(frequency = n(), .groups = "drop")  # Count occurrences of each group size

```{r load_count, message=FALSE, eval=FALSE, warning=FALSE, comments=""}
read_counts <- read_tsv( "https://sid.erda.dk/share_redirect/G2guEHWh9v/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE) %>% # MSEB0006
  left_join(read_tsv("https://sid.erda.dk/share_redirect/HiPNk7p4MG/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0009
  left_join(read_tsv("https://sid.erda.dk/share_redirect/cdU6P6sNuj/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0010
  left_join(read_tsv("https://sid.erda.dk/share_redirect/EUKYidpvOO/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0011
  left_join(read_tsv("https://sid.erda.dk/share_redirect/dEy2D1OmZi/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0012
  left_join(read_tsv("https://sid.erda.dk/share_redirect/B0E8AbA7Eu/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0014
  left_join(read_tsv("https://sid.erda.dk/share_redirect/hT3CftfSyw/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0015
  rename(genome = 1) %>% # rename first column to 'genome'
  pivot_longer(!genome, names_to = "data", values_to = "counts") %>% # pivot to a long 2-column table (columns: data, counts)
  mutate(sample = substr(data, 1, 7)) %>% # make new column ('sample') from column 'data', by keeping the first 7 characters - i.e. remove the .lib1 ending
  filter(grepl("^M", sample)) %>% # filter to only keep microsamples starting from M (so, remove the 'undetermined' )
  group_by(genome, sample) %>%
  summarise(counts = sum(counts), .groups = "drop") %>% # sum counts from same genome-sample group (i.e. for MSEB0009 & MSEB0010)
  pivot_wider(names_from = "sample", values_from = "counts") # make table wide again (i.e. columns become sample)
```





## Genome covered bases data
Same comments & questions as for count tables!
This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values.

```{r load_hits, message=FALSE, eval=FALSE}
genome_covered_bases <- read_tsv("https://sid.erda.dk/share_redirect/G2guEHWh9v/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE) %>% # MSEB0006
  left_join(read_tsv("https://sid.erda.dk/share_redirect/HiPNk7p4MG/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0009
  left_join(read_tsv("https://sid.erda.dk/share_redirect/cdU6P6sNuj/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0010
  left_join(read_tsv("https://sid.erda.dk/share_redirect/EUKYidpvOO/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0011
  left_join(read_tsv("https://sid.erda.dk/share_redirect/dEy2D1OmZi/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0012
  left_join(read_tsv("https://sid.erda.dk/share_redirect/B0E8AbA7Eu/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0014
  left_join(read_tsv("https://sid.erda.dk/share_redirect/hT3CftfSyw/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv", show_col_types = FALSE), by = "sequence_id") %>% # MSEB0015
  rename(genome = 1) %>%
  pivot_longer(!genome, names_to = "data", values_to = "counts") %>%
  mutate(sample = substr(data, 1, 7)) %>%
  group_by(genome, sample) %>%
  summarise(counts = sum(counts), .groups = "drop") %>%
  pivot_wider(names_from = "sample", values_from = "counts") %>% 
  select(-Undeter)

```



## Genome (MAGs) metadata
Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses.

The number of genomes in these files matches the number of genomes in the count tables. 
So, I assume that Antton has downloaded/provided the files for REF0009. 
But, I could not find the relevant files in ERDA>3D'omics>references>REF0009-mggp.

### Genome (MAGs) taxonomy
This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses.
```{r load_taxonomy, message=FALSE, eval=FALSE}
genome_taxonomy <- read_tsv("data/genome_taxonomy.tsv", show_col_types = FALSE) %>%
  rename(genome = user_genome) %>% # rename first column
  mutate(genome = str_replace_all(genome, "\\.fa", "")) %>% # remove .fa from the end of each genome name
  separate(classification, c("domain", "phylum", "class", "order", "family", "genus", "species"), sep = ";") %>% # separate column 'classification' into columns for the different taxonomic levels
  mutate(across(domain:species, ~ str_sub(., 4))) %>% # remove reduntant letters before taxon names
  select(genome, domain, phylum, class, order, family, genus, species) %>% # select the relevant columns
  arrange(match(genome, read_counts$genome)) # reorder the rows of taxonomy df based on the order of the read_counts df
```

### Genome (MAGs) quality
Quality properties of the genomes. 
```{r load_quality, message=FALSE, eval=FALSE}
genome_quality <- read_tsv("data/genome_quality.tsv", show_col_types = FALSE) %>%
  rename(genome = 1) %>% # rename first column
  mutate(genome = str_replace_all(genome, "\\.fa", "")) %>% # remove .fa from the end of each genome name
  arrange(match(genome, read_counts$genome)) %>% # reorder the rows of taxonomy df based on the order of the read_counts df
  select(genome, Completeness, Contamination, Coding_Density, Genome_Size) %>% # select relevant columns
  rename(completeness = Completeness, contamination = Contamination, coding_density = Coding_Density, length = Genome_Size) # rename columns
```

### Merged Genome (MAGs) taxonomy & quality
Merge taxonomy, length and quality information
```{r create_genomemetadata, message=FALSE, eval=FALSE}
genome_metadata <- genome_taxonomy %>%
  left_join(genome_quality, by = join_by(genome == genome)) # join quality
```

### Genome (MAGs) tree
This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes.
```{r load_tree, message=FALSE, warning=FALSE, eval=FALSE}
genome_tree <- read.tree("data/genome_tree.tre")
genome_tree$tip.label <- str_replace_all(genome_tree$tip.label, "'", "") # remove single quotes in MAG names
genome_tree <- keep.tip(genome_tree, tip = read_counts$genome) # keep only MAG tips
```

### Genome (MAGs) functional annotations
This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR.
```{r load_annotations, message=FALSE, eval=FALSE}
genome_annotations <- read_tsv("data/genome_annotations.tsv.xz", show_col_types = FALSE) %>%
  rename(gene = 1, genome = 2)
```

### Distil functional annotations
Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses.
```{r distill_annotations, warning=FALSE, comments="", message=FALSE, results='hide', eval=FALSE}
genome_gifts <- distill(genome_annotations, GIFT_db, genomecol = 2, annotcol = c(9, 10, 19))
```





## Sample metadata

Import sample metadata from the airtable.
```{r sample_metadata, message=FALSE, eval=FALSE}
sample_metadata <- airtable("4-MSE-Info", "appKakM1bnKSekwuW") %>% # get base ID from Airtable browser URL
  read_airtable(., fields = c(
    "ID", "LabBatch_text", "IntestinalSection", "SampleType",
    "Xcoord", "Ycoord", "SizeApprox", "cryosection_text", "buffer_text",
    "Collection_Success", "Collection_attempts", "UsedCycles", "animal_temp", "Protocol_text",
    "Collection_method_text"
  ), id_to_col = TRUE) %>%
  filter(LabBatch_text %in% c("MSEB0006", "MSEB0009", "MSEB0010", "MSEB0011", "MSEB0012", "MSEB0014", "MSEB0015")) %>%
  rename(
    batch = LabBatch_text,
    microsample = ID,
    section = IntestinalSection,
    type = SampleType,
    cryosection = cryosection_text,
    buffer = buffer_text,
    collection = Collection_Success,
    collection_attempts = Collection_attempts,
    cycles = UsedCycles,
    animal = animal_temp,
    size = SizeApprox,
    protocol = Protocol_text,
    collection_method = Collection_method_text
  ) %>%
  select(
    microsample, section, type, batch,
    cryosection, buffer, Xcoord, Ycoord,
    size, collection, collection_attempts,
    cycles, animal, protocol, collection_method
  ) %>%
  unnest(c(section, Xcoord, Ycoord, size, collection, cycles, collection_method)) %>%
  mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) %>% 
  mutate(type_simple = substr(type, 1, 1)) %>%
  arrange(microsample)
```










## Sequencing statistics data
For the analysis of different batches mapped to reference REF009, I define lists with the names of the files required for the statistics. 
The files were produced by Jorge's bioinformatics pipeline (g_mg), and located in 3D'omics ERDA.
Then, I import the relevant columns of each file with a loop, through a function.
I use a function to avoid creating intermediate dataframes for each statistic. 
I use all the functions at the end to create the general statistics table. 

### Sequencing statistics before trimming
Used the multiqc_fastqc.txt because the multiqc_general_stats.txt did not exist in all batches.
```{r stats_before_trim_file_list, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_before_trim_file_list <- c(
  "https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0006
  "https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0009
  "https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0010
  "https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0011
  "https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0012
  "https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/reads_data/multiqc_fastqc.txt", # MSEB0014
  "https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/reads_data/multiqc_fastqc.txt" # MSEB0015
)
```

```{r stats_before_trim_load_function, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_before_trim_load_function <- function(file) {
  read_tsv(file,
    col_types = cols_only(
      "Sample" = col_character(), # define the type of column (text, numbers, etc.)
      "Total Sequences" = col_double(),
      "%GC" = col_double(),
      "total_deduplicated_percentage" = col_double()
    ),
    show_col_types = FALSE # ask R not to print out the type of each column
  ) %>%
    mutate(Sample = str_extract(Sample, "M\\d+")) %>% # extract sample name starting from "M" with numbers that follow M. Different names will turn to "'"NA"
    rename( # rename columns
      microsample = Sample,
      total_sequences_before_trim = `Total Sequences`,
      percent_gc_before_trim = `%GC`,
      percent_unique_before_trim = total_deduplicated_percentage
    ) %>%
    select(microsample, total_sequences_before_trim, percent_gc_before_trim, percent_unique_before_trim)
}
```

```{r stats_files_before_trim_load, warning=FALSE, comments="", message=FALSE, eval=FALSE}
# apply the function to all files in the list, then bind all the tables together
stats_before_trim <- bind_rows(lapply(stats_before_trim_file_list, stats_before_trim_load_function)) %>%
  group_by(microsample) %>% # because there are at least two rows per sample in the multi_fastqc files.
  summarise(
    total_sequences_before_trim = sum(total_sequences_before_trim, na.rm = TRUE), # sum the no. of sequences in the rows of each sample
    percent_gc_before_trim = mean(percent_gc_before_trim, na.rm = TRUE), # mean of GC% for the two rows. Only works when the no.of sequences is the same in the two rows -> Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010)
    percent_unique_before_trim = mean(percent_unique_before_trim, na.rm = TRUE) # mean of unique% for the two rows. Only works when the no.of sequences is the same in the two rows -> Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010)
  )
```

### Sequencing statistics after trimming
```{r stats_after_trim_file_list, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_after_trim_file_list <- c(
 "https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0006
 "https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0009
 "https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0010
 "https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0011
 "https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0012
 "https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/multiqc_fastqc.txt", # MSEB0014 
 "https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_fastqc.txt" # MSEB0015
)
```

```{r stats_after_trim_load_function, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_after_trim_load_function <- function(file) {
  read_tsv(file,
    col_types = cols_only(
      "Sample" = col_character(), # define the type of column (text, numbers, etc.)
      "Total Sequences" = col_double(),
      "%GC" = col_double(),
      "total_deduplicated_percentage" = col_double()
    ),
    show_col_types = FALSE # ask R not to print out the type of each column
  ) %>%
    mutate(Sample = str_extract(Sample, "M\\d+")) %>% # extract sample name starting from "M" with numbers that follow M. Different names will turn to "'"NA"
    rename( # rename columns
      microsample = Sample,
      total_sequences_after_trim = `Total Sequences`,
      percent_gc_after_trim = `%GC`,
      percent_unique_after_trim = total_deduplicated_percentage
    ) %>%
    select(microsample, total_sequences_after_trim, percent_gc_after_trim, percent_unique_after_trim)
}
```

```{r stats_files_after_trim_load, warning=FALSE, comments="", message=FALSE, eval=FALSE}
# apply the function to all files in the list, then bind all the tables together
stats_after_trim <- bind_rows(lapply(stats_after_trim_file_list, stats_after_trim_load_function)) %>%
  group_by(microsample) %>% # because there are at least two rows per sample in the multi_fastqc files.
  summarise(
    total_sequences_after_trim = sum(total_sequences_after_trim, na.rm = TRUE), # sum the no. of sequences in the rows of each sample
    percent_gc_after_trim = mean(percent_gc_after_trim, na.rm = TRUE), # mean of GC% for the two rows. Only works when the no.of sequences is the same in the two rows -> Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010)
    percent_unique_after_trim = mean(percent_unique_after_trim, na.rm = TRUE) # mean of unique% for the two rows. Only works when the no.of sequences is the same in the two rows -> Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010)
  )
```

Two rows are missing after trimming. Which ones?
M300703 from MSEB0009
M300723 from MSEB0010
```{r failed_samples_after_trimming, warning=FALSE, comments="", message=FALSE, eval=FALSE}
anti_join(stats_before_trim, stats_after_trim, by = "microsample")
```

### Non-bacterial mapped reads: human,chicken, swine 
This is calculated on the trimmed reads. 
The reads are mapped to 3 databases (1. human (GRCh38), 2. chicken (GRCg7b), 3. pig (Sscrofa11.1)) sequentially.
From file 'multiqc_samtools_flagstat': 
  To find the number of reads mapped to each reference you have to either
  - sum the columns: 'mapped_passed' and 'singletons_passed' OR
  - subtract the number of reads that entered the analysis (e.g. column 'total_passed' of human - from column 'total_passed' of chicken = reads mapped to human).
  If you try both, these numbers should be equal. 
After the final analysis, the plan is to get one count table with all these numbers (together with bacteria, and not mapped).
```{r non_bacteria_mapping_files_list, warning=FALSE, comments="", message=FALSE, eval=FALSE}
non_bacteria_mapping_files_list <- c(
  "https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0006
  "https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0009
  "https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0010
  "https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0011
  "https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0012
  "https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt", # MSEB0014
  "https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt" # MSEB0015
)
```

```{r non_bacteria_mapping_load_function, warning=FALSE, comments="", message=FALSE, eval=FALSE}
non_bacteria_mapping_load_function <- function(file) {
  read_tsv(file, show_col_types = FALSE) %>%
    mutate(reference = case_when(
      grepl("GRCh38", Sample, ignore.case = TRUE) ~ "human",
      grepl("GRCg7b", Sample, ignore.case = TRUE) ~ "chicken",
      grepl("Sscrofa11.1", Sample, ignore.case = TRUE) ~ "swine",
      TRUE ~ NA_character_
    )) %>%
    mutate(
      microsample = str_extract(Sample, "M\\d+"),
      chicken_total_passed = ifelse(reference == "chicken", total_passed, NA_real_),
      human_total_passed = ifelse(reference == "human", total_passed, NA_real_),
      swine_total_passed = ifelse(reference == "swine", total_passed, NA_real_),
      chicken_mapped_passed = ifelse(reference == "chicken", mapped_passed, NA_real_),
      human_mapped_passed = ifelse(reference == "human", mapped_passed, NA_real_),
      swine_mapped_passed = ifelse(reference == "swine", mapped_passed, NA_real_),
      chicken_singletons_passed = ifelse(reference == "chicken", singletons_passed, NA_real_),
      human_singletons_passed = ifelse(reference == "human", singletons_passed, NA_real_),
      swine_singletons_passed = ifelse(reference == "swine", singletons_passed, NA_real_),
      chicken_total_mapped = ifelse(reference == "chicken", mapped_passed + singletons_passed, NA_real_),
      human_total_mapped = ifelse(reference == "human", mapped_passed + singletons_passed, NA_real_),
      swine_total_mapped = ifelse(reference == "swine", mapped_passed + singletons_passed, NA_real_),
      swine_unmapped = ifelse(reference == "swine", swine_total_passed - swine_total_mapped, NA_real_)
    ) %>%
    select(microsample,
           chicken_total_passed, human_total_passed, swine_total_passed,
           chicken_mapped_passed, human_mapped_passed, swine_mapped_passed,
           chicken_singletons_passed, human_singletons_passed, swine_singletons_passed,
           chicken_total_mapped, human_total_mapped, swine_total_mapped, swine_unmapped) %>%
    group_by(microsample) %>%
    summarise(across(starts_with("chicken_") | starts_with("human_") | starts_with("swine_"), sum, na.rm = TRUE))
}
```

```{r stats_non_bacteria_mapping_load, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_non_bacteria_mapping <- bind_rows(lapply(non_bacteria_mapping_files_list, non_bacteria_mapping_load_function))
```


### Bacterial mapped reads
This is calculated on the trimmed reads after filtering for human, chicken, and pig reads.
'Unmapped reads' at this point are trimmed but not mapped to human, chicken, pig, or bacterial MAG catalogue.
```{r bacteria_mapping_files_list, warning=FALSE, comments="", message=FALSE, eval=FALSE}
bacteria_mapping_files_list <- c(
  "https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0006
  "https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0009
  "https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0010
  "https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0011
  "https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0012
  "https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/quantify_data/multiqc_samtools_stats.txt", # MSEB0014
  "https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/quantify_data/multiqc_samtools_stats.txt" # MSEB0015
)
```

```{r bacteria_mapping_load_function, warning=FALSE, comments="", message=FALSE, eval=FALSE}
bacteria_mapping_load_function <- function(file) {
  read_tsv(file, show_col_types = FALSE) %>%
    filter(str_detect(Sample, "mgg-pbdrep")) %>% #select samples mapped to REF0009-gg-pbdrep  database (i.e. NO 'salmonella' or 'chicken big mag')
    mutate(
      microsample = str_extract(Sample, "M\\d+"),
      bacteria_total_passed = raw_total_sequences,
      bacteria_total_mapped = reads_mapped,
      unmapped = reads_unmapped
    ) %>%
    group_by(microsample) %>% 
    summarise(
      bacteria_total_passed = sum(bacteria_total_passed, na.rm = TRUE), # because some samples were sequence multiple times
      bacteria_total_mapped = sum(bacteria_total_mapped, na.rm = TRUE),
      unmapped = sum(unmapped, na.rm = TRUE)
    ) %>%
    select(microsample, bacteria_total_passed, bacteria_total_mapped, unmapped)
}
```

```{r stats_bacteria_mapping_load, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_bacteria_mapping <- bind_rows(lapply(bacteria_mapping_files_list, bacteria_mapping_load_function))
```

Alternative way to estimate bacterial read counts (from count table):
```{r stats_bacteria_mapping_alternative, warning=FALSE, comments="", message=FALSE, eval=FALSE}
# Transpose the table
stats_bacteria_mapping_alternative <- read_counts %>%
  column_to_rownames(var = "genome") %>%  # Move genome names to rownames
  t() %>%                                # Transpose the data
  as.data.frame() %>%                    # Convert back to a data frame
  rownames_to_column(var = "microsample") %>%     # Move sample names into a column
  mutate(bacteria_total_read_counts = rowSums(select(., -microsample))) %>% # sum the counts of all genomes in each sample (i.e. sum of each row)
  select(microsample, bacteria_total_read_counts)%>% # choose to show only the total_counts column
  filter(grepl("^M", microsample)) # choose only microsamples starting with 'M' (i.e. not the 'undetermined')
```

### Combine relevant sequencing statistics
```{r stats_combined, warning=FALSE, comments="", message=FALSE, eval=FALSE}
stats_combined <- reduce(list(stats_before_trim, 
                              stats_after_trim, 
                              stats_non_bacteria_mapping, 
                              stats_bacteria_mapping,
                              stats_bacteria_mapping_alternative), full_join, by = "microsample") %>%
  filter(grepl("^M", microsample))  %>%
  mutate(removed_sequences_after_trim = total_sequences_before_trim - total_sequences_after_trim) %>%
  select(microsample, 
         total_sequences_before_trim, total_sequences_after_trim, removed_sequences_after_trim,
         percent_gc_before_trim, percent_gc_after_trim,
         percent_unique_before_trim, percent_unique_after_trim,
         chicken_total_mapped, human_total_mapped, swine_total_mapped, 
         bacteria_total_mapped, bacteria_total_read_counts, unmapped
         )
```

Estimate some percentages - maybe this is not needed for plotting.
Estimate the quality score of each sample, and add as a new column. 
This is optional and will be updated with a better estimation of quality.
```{r load_process_stats_files, warning=FALSE, comments="", message=FALSE, eval=FALSE}
final_combined_stats <- stats_combined %>%
  mutate(
    trimmed_percentage = ((total_sequences_before_trim-total_sequences_after_trim)/total_sequences_before_trim)*100,
    human_percentage = (human_total_mapped/total_sequences_after_trim)*100,
    chicken_percentage = (chicken_total_mapped/total_sequences_after_trim)*100,
    swine_percentage = (swine_total_mapped/total_sequences_after_trim)*100,
    bacteria_percentage = (bacteria_total_mapped/total_sequences_after_trim)*100,
    unmapped_percentage = (unmapped/total_sequences_after_trim)*100,
    depth = ifelse(total_sequences_after_trim > 1000000, 1, 0),
    duplicates = ifelse(percent_unique_after_trim > 30, 1, 0),
    gc = ifelse(percent_gc_after_trim < 60, 1, 0),
    human = ifelse(human_percentage < 5, 1, 0),
    bacteria = ifelse(bacteria_percentage > 75, 1, 0),
    quality = depth + duplicates + gc + human + bacteria
  )
```





## Bacterial phyla color scheme data
[AlberdiLab](www.alberdilab.dk) projects use unified color schemes developed for the [Earth Hologenome Initiative](www.earthhologenome.org), to facilitate figure interpretation.
```{r get_ehi_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
phylum_colors <- read_tsv("https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv", show_col_types = FALSE) %>%
  mutate(phylum = gsub("^p__", "", phylum)) %>%
  right_join(genome_metadata, by = join_by(phylum == phylum)) %>%
  arrange(match(genome, genome_tree$tip.label)) %>%
  select(phylum, colors) %>%
  unique() %>%
  arrange(phylum) %>%
  pull(colors, name = phylum)
```




## Filter and normalise data
Raw data needs to be filtered and normalised to make it useful for downstream analyses. 

### Generate coverage table
By dividing the number of base hits by the length of each genome, coverage values can be calculated.
```{r calc_coverage, eval=FALSE}
genome_coverage <- genome_covered_bases %>%
  mutate(across(where(is.numeric), ~ . / genome_metadata$length))
```

### Coverage filtering
Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. 
```{r filter_coverage, eval=FALSE}
min_coverage <- 0.3
read_counts_filt_30 <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>% # turn entries of <0.3 to 0, keep the rest to 1
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1)


min_coverage <- 0.2
read_counts_filt_20 <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>% # turn entries of <0.3 to 0, keep the rest to 1
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1)


min_coverage <- 0.1
read_counts_filt_10 <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>% # turn entries of <0.3 to 0, keep the rest to 1
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1)

min_coverage <- 0.05
read_counts_filt_05 <- genome_coverage %>%
  mutate(across(where(is.numeric), ~ ifelse(. > min_coverage, 1, 0))) %>% # turn entries of <0.3 to 0, keep the rest to 1
  mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1)

```


### Generate genome count table
Read counts are transformed into genome counts using genome-length and read-length information.

Explanation:
Read counts are influenced by sequencing depth and genome size. Larger genomes will naturally attract more reads than smaller ones, even if their actual abundance is the same. By normalizing read counts to genome size, genome counts provide a size-independent estimate of how many genome copies (or organisms carrying that genome) are present in a sample.

```{r calc_genometable, eval=FALSE}
readlength <- 150 # change if sequencing read length is different

# Reads without low-coverage filtering:
genome_counts <- read_counts %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength)))

#Reads after filtering the low-coverage reads:
genome_counts_filt_30 <- read_counts_filt_30 %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength)))

genome_counts_filt_20 <- read_counts_filt_20 %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength)))

genome_counts_filt_10 <- read_counts_filt_10 %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength)))

genome_counts_filt_05 <- read_counts_filt_05 %>%
  mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength)))

```




## Wrap working objects
In the last step, the objects that are needed for downstream analyses are stored in an R object.
```{r wrap_objects, eval=FALSE}
save(genome_counts,
  genome_counts_filt_30,
  genome_counts_filt_20,
  genome_counts_filt_10,
  genome_counts_filt_05,
  genome_tree,
  genome_metadata,
  genome_gifts,
  sample_metadata,
  phylum_colors,
  final_combined_stats,
  file = "data/data.Rdata"
)
```

- **read_counts**: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table.
- **genome_counts**: Number of genomes quantified in each sample, calculated through filtering and normalising ***read_counts***. This is the community composition table to be used in downstream analyses unless otherwise stated.
- **genome_tree**: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses.
- **genome_metadata**: Taxonomic and quality information of the genomes.
- **sample_metadata**: Treatment/population and other relevant metadata of the samples.

<!--chapter:end:1-data_import_and_preparation_REF0009.Rmd-->

# Data preparation for plotting 


## Load the data that were prepared in the previous chapter.
```{r load_data_quality, eval=FALSE}
load("data/data.Rdata")
```



## Sequencing statistics dataframes
```{r plot_data_stats, warning=FALSE, comments="", message=FALSE, eval=FALSE}
plot_data_stats <- final_combined_stats %>%
  left_join(sample_metadata, by = join_by(microsample == microsample))
```

Make tidy table for sequencing stats before & after trimming
```{r tidy_plot_data_stats_before_after, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_data_stats_before_after <- plot_data_stats %>%
  pivot_longer(
    cols = c(
    total_sequences_before_trim, total_sequences_after_trim,
    percent_gc_before_trim, percent_gc_after_trim,
    percent_unique_before_trim, percent_unique_after_trim
    ),
    names_to = c("Metric", "Condition"), # Split column names
    names_pattern = "(.*)_(before|after)_trim"
  ) %>%
  pivot_wider(
    names_from = Metric,
    values_from = value
  ) %>%
  mutate(
    Condition = factor(Condition,
                   levels = c("before", "after")))
```

Make tidy table for counts
```{r tidy_plot_data_stats_counts, warning=FALSE, comments="", message=FALSE, eval=FALSE}
category_counts <- tibble::tibble(
  category = c(
    "bacteria_total_mapped", "chicken_total_mapped",
    "human_total_mapped", "swine_total_mapped",
    "unmapped", "removed_sequences_after_trim"),
  label = c("Bacteria",  "Chicken", "Human",  "Swine",  "Unmapped", "Removed"),
  color = c( "#B92D65", "#E8BD50", "#1092b4", "#3baf6f", "#8d98ae", "#2b2d42"))

tidy_plot_data_stats_counts <- plot_data_stats %>%
  pivot_longer(
    cols = c(
      chicken_total_mapped, human_total_mapped,
      swine_total_mapped, bacteria_total_mapped,
      unmapped, removed_sequences_after_trim),
    names_to = "mapping_status", values_to = "counts") %>%
  left_join(category_counts, by = c("mapping_status" = "category")) %>%
  mutate( # order the groups in desired order
    label = factor(label,
                   levels = c("Bacteria", "Chicken", "Human", "Swine", "Unmapped", "Removed")))

# Set labels & colours as colour palette
color_palette_tidy_plot_data_stats_counts <- setNames(category_counts$color, category_counts$label)
```


## Count tables dataframes

Make tidy tables for genome counts
```{r tidy_plot_genome_counts, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_genome_counts <-  genome_counts %>%
    mutate_at(vars(-genome), ~ . / sum(.)) %>% # scale each sample to 1
    pivot_longer(-genome, names_to = "microsample", values_to = "count") %>% 
    left_join(genome_metadata, by = join_by(genome == genome)) %>% 
    left_join(sample_metadata, by = join_by(microsample == microsample)) %>% 
    left_join(final_combined_stats, by = join_by(microsample == microsample)) %>%
    mutate(section = unlist(section)) %>% # Flatten section if it's a list
    filter(count > 0) # Filter out rows with count <= 0 (that are redundant after pivot_longer, but important for b div)
```


And then do the same for filtered counts at different coverage thresholds
```{r tidy_plot_genome_counts_filt_05, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_genome_counts_filt_05 <-  genome_counts_filt_05 %>%
    mutate_at(vars(-genome), ~ . / sum(.)) %>% 
    pivot_longer(-genome, names_to = "microsample", values_to = "count") %>% 
    left_join(genome_metadata, by = join_by(genome == genome)) %>% 
    left_join(sample_metadata, by = join_by(microsample == microsample)) %>% 
    left_join(final_combined_stats, by = join_by(microsample == microsample)) %>%
    mutate(section = unlist(section)) %>% 
    filter(count > 0) 
```

```{r tidy_plot_genome_counts_filt_10, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_genome_counts_filt_10 <-  genome_counts_filt_10 %>%
    mutate_at(vars(-genome), ~ . / sum(.)) %>% 
    pivot_longer(-genome, names_to = "microsample", values_to = "count") %>% 
    left_join(genome_metadata, by = join_by(genome == genome)) %>% 
    left_join(sample_metadata, by = join_by(microsample == microsample)) %>% 
    left_join(final_combined_stats, by = join_by(microsample == microsample)) %>%
    mutate(section = unlist(section)) %>% 
    filter(count > 0) 
```

```{r tidy_plot_genome_counts_filt_20, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_genome_counts_filt_20 <-  genome_counts_filt_20 %>%
    mutate_at(vars(-genome), ~ . / sum(.)) %>% 
    pivot_longer(-genome, names_to = "microsample", values_to = "count") %>% 
    left_join(genome_metadata, by = join_by(genome == genome)) %>% 
    left_join(sample_metadata, by = join_by(microsample == microsample)) %>% 
    left_join(final_combined_stats, by = join_by(microsample == microsample)) %>%
    mutate(section = unlist(section)) %>% 
    filter(count > 0) 
```

```{r tidy_plot_genome_counts_filt_30, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_genome_counts_filt_30 <-  genome_counts_filt_30 %>%
    mutate_at(vars(-genome), ~ . / sum(.)) %>% 
    pivot_longer(-genome, names_to = "microsample", values_to = "count") %>% 
    left_join(genome_metadata, by = join_by(genome == genome)) %>% 
    left_join(sample_metadata, by = join_by(microsample == microsample)) %>% 
    left_join(final_combined_stats, by = join_by(microsample == microsample)) %>%
    mutate(section = unlist(section)) %>% 
    filter(count > 0) 
```




## Alpha diversity dataframes

Define function to estimate the genomes' alpha diversity measurements from genome counts.
```{r calculate_alpha_diversity, warning=FALSE, comments="", message=FALSE, eval=FALSE}
calculate_alpha_diversity <- function(input_data, dataset_name) {
  # Step 1: Transform the input data (remove rownames if needed)
  input_data_matrix <- input_data %>%
    column_to_rownames(var = "genome")

  # Step 2: Calculate richness (q = 0)
  richness <- hilldiv(input_data_matrix, q = 0) %>%
    t() %>%
    as.data.frame() %>%
    rename(richness = 1) %>%
    rownames_to_column(var = "microsample")

  # Step 3: Calculate neutral diversity (q = 1)
  neutral <- hilldiv(input_data_matrix, q = 1) %>%
    t() %>%
    as.data.frame() %>%
    rename(neutral = 1) %>%
    rownames_to_column(var = "microsample")

  # Step 4: Calculate phylogenetic diversity (q = 1, with genome tree)
  phylogenetic <- hilldiv(input_data_matrix, q = 1, tree = genome_tree) %>%
    t() %>%
    as.data.frame() %>%
    rename(phylogenetic = 1) %>%
    rownames_to_column(var = "microsample")

  # Step 5: Merge all diversity metrics
  alpha_diversity <- richness %>%
    full_join(neutral, by = "microsample") %>%
    full_join(phylogenetic, by = "microsample") # %>%
    # left_join(sample_metadata, by = "microsample") %>%
    # left_join(final_combined_stats, by = "microsample") %>%

  # Return the alpha_diversity data frame
  return(alpha_diversity)
}
```

Estimate the alpha diversity on the unfiltered and the coverage-filtered counts
```{r alpha_diversities_filtered, warning=FALSE, comments="", message=FALSE, eval=FALSE}
alpha_div_unfiltered <- calculate_alpha_diversity(
  input_data = genome_counts,
  dataset_name = "unfiltered") %>%
  mutate(filter_level = "unfiltered")

alpha_div_filtered_05 <- calculate_alpha_diversity(
  input_data = genome_counts_filt_05,
  dataset_name = "filtered") %>% 
  mutate(filter_level = "filtered_05")

alpha_div_filtered_10 <- calculate_alpha_diversity(
  input_data = genome_counts_filt_10,
  dataset_name = "filtered") %>% 
  mutate(filter_level = "filtered_10")

alpha_div_filtered_20 <- calculate_alpha_diversity(
  input_data = genome_counts_filt_20,
  dataset_name = "filtered")  %>% 
  mutate(filter_level = "filtered_20")

alpha_div_filtered_30 <- calculate_alpha_diversity(
  input_data = genome_counts_filt_30,
  dataset_name = "filtered")  %>% 
  mutate(filter_level = "filtered_30")

``` 

```{r alpha_diversity, warning=FALSE, comments="", message=FALSE, eval=FALSE}
alpha_diversity <- bind_rows(
  alpha_div_unfiltered,
  alpha_div_filtered_05,
  alpha_div_filtered_10,
  alpha_div_filtered_20,
  alpha_div_filtered_30) %>%
  left_join(sample_metadata, by = "microsample") %>%
  left_join(final_combined_stats, by = "microsample") %>%
  mutate(filter_level = factor(filter_level, levels = c("unfiltered", "filtered_05", "filtered_10", "filtered_20",  "filtered_30")))
```

Make tidy a-diversity
```{r tidy_plot_alpha_diversity_genomes, warning=FALSE, comments="", message=FALSE, eval=FALSE}
tidy_plot_alpha_diversity_genomes <- alpha_diversity %>%
  pivot_longer(
    cols = c(richness, neutral, phylogenetic), 
    names_to = "metric",                      
    values_to = "value"                       
  ) %>%
      mutate(metric = factor(metric, levels = c("richness", "neutral", "phylogenetic")))
```


## Wrap working objects
In the last step, the objects that are needed for downstream analyses are stored in an R object.
```{r wrap_objects_plot, eval=FALSE}
save(plot_data_stats,
  tidy_plot_data_stats_before_after,
  tidy_plot_data_stats_counts,
  color_palette_tidy_plot_data_stats_counts,
  tidy_plot_genome_counts,
  tidy_plot_genome_counts_filt_05,
  tidy_plot_genome_counts_filt_10,
  tidy_plot_genome_counts_filt_20,
  tidy_plot_genome_counts_filt_30,
  tidy_plot_alpha_diversity_genomes,
  phylum_colors,
  file = "data/plot_data.Rdata"
)
```

<!--chapter:end:2-data_prep_for_plotting_REF0009.Rmd-->

# List of experiments
Define lists that contain the plot settings for different experiments


### B11 vs B12 lysis buffers
Compare buffer B11 and B12.
Use batches MSEB0006 (caecum) and MSEB0010 (colon), from the focal (adult) chicken. 
For the colon, use the samples that were amplified with 15 PCR cycles instead of 19 (due to the latter's low quality).
```{r data_set_buffers, warning=FALSE, comments="", message=FALSE}
plot_params_buffers <- list(
  filter_conditions = list(
    quote(section != "Ileum"),
    quote(cycles < 16),
    quote(batch == "MSEB0006" | batch == "MSEB0010")
  ),
  labels_title = "Lysis Buffer",
  facet_formula = ". ~ section + type + buffer", #"batch + section + type ~ ."
  scale_fill_manual_val = c('#ffdf9e','#ffc273'),
  fill_var = "buffer",
  plot_title = "Lysis Buffer trial"
)
```

#### 15 vs 19 PCR cycles
Use the colon samples (MSEB0010). Maybe separate by buffer??
```{r data_set_cycles, message=FALSE, warning=FALSE, comments=""}
plot_params_cycles <- list(
  filter_conditions = list(
    quote(batch == "MSEB0010")
  ),
  labels_title = "PCR cycles",
  facet_formula = "section + type + cycles ~ .", # "batch + section + type ~ ."
  scale_fill_manual_val = c('#ffc273','#e56969'),
  fill_var = "factor(cycles)",
  plot_title = "PCR cycles trial"
)
```

#### Limit of detection trial: Different LMD sizes
Use batch MSEB0014 (caecum). 
```{r data_set_LOD, warning=FALSE, comments="", message=FALSE}
plot_params_LOD <- list(
  filter_conditions = list(
    quote(batch == "MSEB0014")
  ),
  labels_title = "LMD size",
  facet_formula = "type + size ~ .", #"batch + section + type + cryosection ~ ."
  scale_fill_manual_val = c('#ffdf9e','#ffc273','#e56969','#c1558b','#8a49a1','#4f5bd5'),
  fill_var = "factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))",
  plot_title = "Limit of detection (LMD size)"
)
```

#### Automation trial
Compare library prep with DreamPrep (MSEB0015) vs manual (MSEB0011) for ceacum of focal chicken
```{r data_set_automation, warning=FALSE, comments="", message=FALSE}
plot_params_automation <- list(
  filter_conditions = list(
    quote(batch == "MSEB0011"|batch == "MSEB0015"), 
    quote(animal == 'G121e')
  ),
  labels_title = "Automation",
  facet_formula = "batch + type + cryosection ~ .", #"batch + section + type + cryosection ~ ."
  scale_fill_manual_val = c('#e56969','#c1558b'),
  fill_var = "batch",
  plot_title = "Automation test"
)
```

#### Full vs. half reaction (library prep with UltraLowV2 Tecan kit)
Compare library prep with full reaction (MSEB0006, MSEB0009, MSEB0010) vs half reaction (MSEB0011, MSEB0012) of focal chicken, ceacum and colon (only low PCR cycles). NB! both buffers.
```{r data_set_protocol, warning=FALSE, comments="", message=FALSE}
plot_params_protocol <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch != "MSEB0014"& batch != "MSEB0015"),
    quote(animal == 'G121e'),
    quote(cycles<16)
  ),
  labels_title = "Protocol",
  facet_formula = "type + section + protocol ~ .", #"type + section + batch ~ ."
  scale_fill_manual_val = c('#c1558b','#8a49a1'),
  fill_var = "protocol",
  plot_title = "Full vs. half reactions"
)
```

#### Ceacum vs colon
Compare colon vs caecum samples of the focal chicken (and only low PCR cycles)
```{r data_set_section, warning=FALSE, comments="", message=FALSE}
plot_params_section <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch == "MSEB0009"|batch == "MSEB0010"|batch == "MSEB0011"|batch == "MSEB0012"),
    quote(animal == 'G121e'),
    quote(cycles<16)
  ),
  labels_title = "Section",
  facet_formula = "type + section ~ .", #"type+ batch ~ ."
  scale_fill_manual_val = c('#8a49a1','#4f5bd5'),
  fill_var = "section",
  plot_title = "Caecum vs colon"
)
```

#### Adult vs young chicken
Compare samples from the focal (adult) chicken vs the younger chicken, for both colon (MSEB0012) and caecum (MSEB0011).
```{r data_set_animal, warning=FALSE, comments="", message=FALSE}
plot_params_animal <- list(
  filter_conditions = list(
    quote(batch == "MSEB0011"|batch == "MSEB0012") 
  ),
  labels_title = "Animal",
  facet_formula = "type + section + animal ~ .", #"type+ batch + section + animal ~ ."
  scale_fill_manual_val = c('#ffc273','#c1558b'),
  fill_var = "animal",
  plot_title = "Adult vs young chicken"
)
```

#### LMD collection attemps
Compare samples coloured by the number of attempts to collect the LMD sample. LOD trial excluded.
```{r data_set_collection_attempts, warning=FALSE, comments="", message=FALSE}
plot_params_collection_attempts <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch != "MSEB0014"),
    quote(animal == 'G121e'),
    quote(cycles<16),
    quote(collection_attempts>0)
  ),
  labels_title = "Collection attempts",
  facet_formula = "type + section + collection_attempts ~ .", #"type + section + batch ~ ."
  scale_fill_manual_val = c('#ffdf9e','#ffc273','#e56969','#c1558b','#8a49a1','#4f5bd5'),
  fill_var = "factor(collection_attempts)",
  plot_title = "LMD collection attempts"
)
```

#### LMD collection success
Compare samples coloured by the LMD success jugded upon visual inspection of the collection lids. LOD trial excluded.
```{r data_set_collection_success, warning=FALSE, comments="", message=FALSE}
plot_params_collection_success <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch != "MSEB0014"),
    quote(animal == 'G121e'),
    quote(cycles<16),
    quote(collection_attempts>0)
  ),
  labels_title = "Collection_success",
  facet_formula = "type + section + collection ~ .", #"type + section + batch ~ ."
  scale_fill_manual_val = c('#ffc273','#e56969','#c1558b','#8a49a1','#4f5bd5'),
  fill_var = "collection",
  plot_title = "LMD collection success"
)
```

#### LMD collection container
Compare samples coloured by the container they were collected in during the microsection.
```{r data_set_container_collection, warning=FALSE, comments="", message=FALSE}
plot_params_container_collection <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch == "MSEB0009"),
    quote(cycles<16), 
  quote(protocol == "ULV2_Full")
  ),
  labels_title = "Collection_container",
  facet_formula = "type + collection_method ~ .",
  scale_fill_manual_val = c('#c1558b','#4f5bd5'),
  fill_var = "collection_method",
  plot_title = "LMD collection container"
)
```


#### Sections of Ceacum vs colon
Compare colon vs caecum samples of the focal chicken (and only low PCR cycles)
```{r data_set_slices, warning=FALSE, comments="", message=FALSE}
plot_params_slices <- list(
  filter_conditions = list(
    quote(section != "Ileum"), 
    quote(batch == "MSEB0011"|batch == "MSEB0012"),
    quote(animal == 'G121e'),
    quote(cycles<16)
  ),
  labels_title = "Section",
  facet_formula = "type + section + cryosection ~ .", #"type+ batch ~ ."
  scale_fill_manual_val = c('#e56969','#8a49a1'),
  fill_var = "section",
  plot_title = "Caecum vs colon"
)
```

### Define a list of all the experiments/trials settings that you want to plot.

```{r experiment_settings_list, warning=FALSE, comments="", message=FALSE}
plot_params_list <- list(
  plot_buffers = plot_params_buffers, 
  plot_cycles = plot_params_cycles,
  plot_LOD = plot_params_LOD,
  plot_automation = plot_params_automation,
  plot_protocol = plot_params_protocol,
  plot_section = plot_params_section,
  plot_animal = plot_params_animal,
  plot_collection_attempts = plot_params_collection_attempts,
  plot_collection_success = plot_params_collection_success,
  plot_container_collection = plot_params_container_collection,
  plot_slices = plot_params_slices
)

```

  
### Define lists that contain the settings for plotting each statistic.

#### Sequencing depth
This is the total number of sequenced reads.
```{r stat_params_total_sequences, warning=FALSE, comments="", message=FALSE}
stat_params_total_sequences <- list(
  x_var = "total_sequences",
  x_label = "Number of reads",
  x_vline = 10000000,
  stacked = FALSE
)
```

#### Number of sequences after trimming
This is the total number of sequenced reads after trimming the adaptors and low quality sequences.
```{r stat_params_trimmed_sequences, warning=FALSE, comments="", message=FALSE}
stat_params_trimmed_sequences <- list(
  x_var = "total_trimmed_sequences",
  x_label = "Number of trimmed reads",
  x_vline = NULL,
  stacked = FALSE
)
```

#### Number of trimmed sequences
This is the difference between total reads and reads after trimming.
```{r stats_plot_param_total_trimmed, warning=FALSE, comments="", message=FALSE}
prepare_stacked_data <- function(data) {
  data %>%
    mutate(trimmed_reads = total_sequences - total_trimmed_sequences) %>%
    pivot_longer(cols = c(total_trimmed_sequences, trimmed_reads),
                 names_to = "read_type", values_to = "reads") %>%
    mutate(read_type = factor(read_type, levels = c("trimmed_reads", "total_trimmed_sequences")))
}

stat_params_compare_sequences <- list(
  x_var = "total_trimmed_sequences",
  x_label = "Number of trimmed reads",
  x_vline = NULL,
  stacked = TRUE
)
```

#### Percentage (%) of unique sequences
```{r stat_params_unique, warning=FALSE, comments="", message=FALSE}
stat_params_unique <- list(
  x_var = "percent_unique",
  x_label = "% of unique sequences",
  x_vline = 35,
  stacked = FALSE
)
```

#### Percentage (%) of GC content
```{r stat_params_gc, warning=FALSE, comments="", message=FALSE}
stat_params_gc <- list(
  x_var = "percent_gc",
  x_label = "% of GC content",
  x_vline = 60,
  stacked = FALSE
)
```

#### Percentage (%) of host reads
```{r stat_params_host_reads, warning=FALSE, comments="", message=FALSE}
stat_params_host_reads <- list(
  x_var = "reads_mapped_host_percent",
  x_label = "% of host reads",
  x_vline = NULL,
  stacked = FALSE
)
```

#### Percentage (%) of human reads
```{r stat_params_human_reads, warning=FALSE, comments="", message=FALSE}
stat_params_human_reads <- list(
  x_var = "reads_mapped_human_percent",
  x_label = "% of human reads",
  x_vline = 5,
  stacked = FALSE
)
```

#### Percentage (%) of bacterial reads
NB! In the next iteration, it is better to do this by using the counts dataset instead of the statistics file.
```{r stat_params_bacteria_reads, warning=FALSE, comments="", message=FALSE}
stat_params_bacteria_reads <- list(
  x_var = "reads_mapped_bacteria_percent",
  x_label = "% of bacteria reads",
  x_vline = 75,
  stacked = FALSE
)
```

#### % of unmapped reads
```{r stat_params_other_reads, warning=FALSE, comments="", message=FALSE}
stat_params_other_reads <- list(
  x_var = "reads_mapped_other_percent",
  x_label = "% of other reads",
  x_vline = 25,
  stacked = FALSE
)
```

#### Quality score
```{r stat_quality_score, warning=FALSE, comments="", message=FALSE}
stat_quality_score <- list(
  x_var = "quality",
  x_label = "Quality score",
  x_vline = 5,
  stacked = FALSE
)
```


### Define a list of all the statistics settings that you want to plot.
```{r stats_settings_list, warning=FALSE, comments="", message=FALSE}
stat_params_list <- list(
  stat_total_sequences = stat_params_total_sequences,
  stat_trimmed_sequences = stat_params_trimmed_sequences,
  stat_compare_sequences = stat_params_compare_sequences,
  stat_unique = stat_params_unique,
  stat_gc = stat_params_gc,
  stat_host = stat_params_host_reads,
  stat_human = stat_params_human_reads,
  stat_bacteria = stat_params_bacteria_reads,
  stat_other = stat_params_other_reads,
  stat_quality = stat_quality_score
)
```

```{r wrap_params_object, eval=FALSE}
save(plot_params_list,
  stat_params_list,
  file = "data/params.Rdata"
)
```

<!--chapter:end:3-data_comparisons_setup.Rmd-->

# Lysis buffer trial (B11 vs B12)


## Load data 
Load the data produced in the previous chapters
```{r load_stats_data, warning=FALSE, comments="", message=FALSE}
# load("data/data.Rdata")
load("data/plot_data.Rdata")
```


## Define plotting settings
```{r custom_ggplot_theme, warning=FALSE, comments="", message=FALSE}
custom_ggplot_theme <- theme(
  strip.text.y.left = element_text(angle = 0),
  strip.text.y.right = element_text(angle = 0),
  axis.text = element_text(size = 10),
  axis.title = element_text(size = 12, face = "bold"),
  strip.background = element_rect(fill = "#dde3e9", color = "white", size = 0.8), # Custom facet strip background
  strip.text = element_text(size = 8, face = "bold", color = "black"), # Custom facet text
  strip.placement = "outside", # Place strip outside the panel grid
  panel.spacing = unit(0.1, "lines"), # Adjust space between panels
  panel.grid.major = element_line(color = "#dde3e9"), # Customize major grid lines
  panel.grid.minor = element_blank(), # Remove minor grid lines
  panel.background = element_rect(fill = "white"), # Change panel background color
  plot.margin = unit(c(1, 1, 1, 1), "cm") # Adjust plot margins to ensure content fits
)
```



## Setup filter conditions
Use batches MSEB0006 (caecum) and MSEB0010 (colon), from the focal (adult) chicken. 
For the colon, use the samples that were amplified with 15 PCR cycles instead of 19 (due to the latter's low quality).

```{r plot_params_buffers, warning=FALSE, comments="", message=FALSE}
plot_params_buffers <- list(
  filter_conditions = list(
    quote(section != "Ileum"),
    quote(cycles < 16),
    quote(batch == "MSEB0006" | batch == "MSEB0010")
  ),
  labels_title = "Lysis Buffer",
  facet_formula = ". ~ section + type + buffer", #"batch + section + type ~ ."
  scale_fill_manual_val = c('#ffdf9e','#ffc273'),
  fill_var = "buffer",
  plot_title = "Lysis Buffer trial"
)

plot_params <- plot_params_buffers
```



## Plots

#### Reads that were removed by trimming, mapped to human, chicken, and swine, mapped to bacteria, and unmapped
```{r plot_buffer_reads_1, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_data_stats_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = counts, fill = label)) +
  geom_col() +
  scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) +
  labs(x = "Microsample",y = "Counts",fill = "Read type") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Number of reads removed by trimming & mapped to human, chicken, swine and bacteria & unmapped")

tidy_plot_data_stats_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = counts, fill = label)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) +
  labs(x = "Microsample",y = "Counts",fill = "Read type") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Ratio of reads removed by trimming & mapped to human, chicken, swine and bacteria & unmapped")
```

#### Reads that were mapped to human, chicken, swine, and bacteria
```{r plot_buffer_reads_2, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_data_stats_counts %>%
  filter(mapping_status %in% c('bacteria_total_mapped',
                               'chicken_total_mapped',
                               'human_total_mapped',
                               'swine_total_mapped')) %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = counts, fill = label)) +
  geom_col() +
  scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) +
  labs(x = "Microsample",y = "Counts",fill = "Read type") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Number of reads mapped to human, chicken, swine and bacteria")


tidy_plot_data_stats_counts %>%
  filter(mapping_status %in% c('bacteria_total_mapped',
                               'chicken_total_mapped',
                               'human_total_mapped',
                               'swine_total_mapped')) %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = counts, fill = label)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) +
  labs(x = "Microsample",y = "Counts",fill = "Read type") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Ratio of reads mapped to human, chicken, swine and bacteria")
```
### Reads mapped to bacteria
```{r plot_buffer_reads_3, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
plot_data_stats %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = bacteria_total_mapped)) +
  geom_col(fill = "#B92D65") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Number of reads mapped to bacteria")

plot_data_stats %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = bacteria_percentage)) +
  geom_col(fill = "#B92D65") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Ratio of reads mapped to bacteria")

tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = count, fill = phylum)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = phylum_colors[-4], drop = FALSE) +
  labs(x = "Microsample",y = "Count", fill = "phylum") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Composition of bacterial phyla in the bacterial reads")

plot_data_stats %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = buffer, y = bacteria_total_mapped)) +
  geom_boxplot(alpha = 1, fill = '#c1558b') +
  facet_nested(. ~ section + type_simple + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  scale_y_continuous(breaks = pretty(plot_data_stats$bacteria_total_mapped, n = 50)) +
  ggtitle("Number of bacterial reads")
```
### Reads that did not map to any of the used references
```{r plot_buffer_reads_4, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
plot_data_stats %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = unmapped)) +
  geom_col(fill = "#8d98ae") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Number of unmapped reads")

plot_data_stats %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = unmapped_percentage)) +
  geom_col(fill = "#8d98ae") +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Ratio of unmapped reads")
```


```{r plot_buffer_reads_5, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = Condition, y = total_sequences, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(breaks = pretty(tidy_plot_data_stats_before_after$total_sequences, n = 30)) +
  ggtitle("Number of reads before and after trimming")

tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = Condition, y = total_sequences, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(breaks = pretty(tidy_plot_data_stats_before_after$total_sequences, n = 80)) +
  ggtitle("Number of reads before and after trimming")
```

```{r plot_buffer_gc_1, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = Condition, y = percent_gc, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) +
  ggtitle("% GC before and after trimming")

# Combined Histogram & density plot
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = percent_gc, y = ..density.., fill = Condition)) +
  geom_histogram(binwidth = 0.4, position = "identity", alpha = 0.5) +
  geom_density(alpha = 0.6) +
  facet_grid(buffer ~ type_simple, scale = "free") +
  geom_vline(xintercept = 50, color = "black", size = 0.5) +
  scale_x_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) +
  ggtitle("Shift in GC% with trimming - Caecum")


tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = Condition, y = percent_gc, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  
  scale_y_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) +
  ggtitle("% GC before and after trimming")

# Combined Histogram & density plot
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = percent_gc, y = ..density.., fill = Condition)) +
  geom_histogram(binwidth = 0.4, position = "identity", alpha = 0.5) +
  geom_density(alpha = 0.6) +
  facet_grid(buffer ~ type_simple, scale = "free") +
  geom_vline(xintercept = 50, color = "black", size = 0.5) +
  scale_x_continuous(
    limits = c(10, 90),
    breaks = seq(10, 90, by = 5)) +
  ggtitle("Shift in GC% with trimming - Colon")

# Histogram
# tidy_plot_data_stats_before_after %>%
#   filter(!!!plot_params$filter_conditions) %>%
#   ggplot(aes(x = percent_gc, fill = Condition)) +
#   geom_histogram(binwidth = 0.5, position = "identity", alpha = 0.7) +
#   facet_grid(buffer ~ type_simple, scale = "free") +
#   xlim(10, 90) +
#   geom_vline(xintercept = 50)+
#   ggtitle("Shift in GC% with trimming")
# 

# Density plot
# tidy_plot_data_stats_before_after %>%
#   filter(!!!plot_params$filter_conditions) %>%
#   ggplot(aes(x = percent_gc, fill = Condition)) +
#   geom_density(alpha=0.7) +
#   facet_grid(buffer ~ type_simple, scale = "free") +
#   xlim(10, 90) +
#   geom_vline(xintercept = 50)+
#   ggtitle("Shift in GC% with trimming")
```

```{r plot_buffer_dp_1, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = Condition, y = percent_unique, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(limits = c(0, 100),breaks = seq(0, 100, by = 5)) +
  ggtitle("% unique seq before and after trimming")

# Combined Histogram & density plot
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = percent_unique, y = ..density.., fill = Condition)) +
  geom_histogram(binwidth = 0.4, position = "identity", alpha = 0.5) +
  geom_density(alpha = 0.6) +
  facet_grid(buffer ~ type_simple, scale = "free") +
  geom_vline(xintercept = 50, color = "black", size = 0.5) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 5)) +
  ggtitle("Shift in unique seq % with trimming - Caecum")


tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = Condition, y = percent_unique, fill = Condition)) +
  geom_boxplot(alpha = 1) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_y_continuous(limits = c(0, 100),breaks = seq(0, 100, by = 5)) +
  ggtitle("% unique seq before and after trimming")

# Combined Histogram & density plot
tidy_plot_data_stats_before_after %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = percent_unique, y = ..density.., fill = Condition)) +
  geom_histogram(binwidth = 0.4, position = "identity", alpha = 0.5) +
  geom_density(alpha = 0.6) +
  facet_grid(buffer ~ type_simple, scale = "free") +
  geom_vline(xintercept = 50, color = "black", size = 0.5) +
  scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 5)) +
  ggtitle("Shift in unique seq % with trimming - Colon")
```

```{r plot_buffer_diversity_1, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_alpha_diversity_genomes %>%
  filter(filter_level == 'unfiltered') %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - not filtered")


tidy_plot_alpha_diversity_genomes %>%
  filter(filter_level == 'filtered_05') %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - genomes filtered at 5% coverage")


tidy_plot_alpha_diversity_genomes %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Caecum right') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer + filter_level, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - 5 coverage filtering levels")

```

```{r plot_buffer_diversity_2, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_alpha_diversity_genomes %>%
  filter(filter_level == 'unfiltered') %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - not filtered")


tidy_plot_alpha_diversity_genomes %>%
  filter(filter_level == 'filtered_05') %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - genomes filtered at 5% coverage")


tidy_plot_alpha_diversity_genomes %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(section == 'Colon') %>%
  ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) +
  scale_color_gradient(low = "#c90076", high = "#3598bf", name = "bacteria percentage", limits = c(0, 100)) +
  geom_boxplot(outlier.shape = NA) +
      geom_jitter(width = 0.2, alpha = 0.7) +
  facet_nested(metric ~ section + type_simple + buffer + filter_level, scales = "free", space = "fixed") +
  theme_minimal() +
  custom_ggplot_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  ggtitle("Alpha diversity - 5 coverage filtering levels")
```



check also how many of the filtered samples (when we do the filtering) belong to each group

```{r plot_buffer_diversity_3, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
# Histogram
tidy_plot_alpha_diversity_genomes %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(metric == 'richness') %>%
  ggplot(aes(x = value, fill = filter_level)) +
  geom_histogram(binwidth = 4, position = "identity", alpha = 0.5) +
  facet_grid(section ~ type_simple + buffer, scales = "fixed", space = "fixed") +
  scale_y_continuous(limits = c(0, 20),breaks = seq(0, 20, by = 1)) +
  theme_minimal() +
  custom_ggplot_theme +
  ggtitle("Histogram: Samples based on their number of genomes depending on coverage filtering")

# Combined Histogram & density plot
tidy_plot_alpha_diversity_genomes %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(metric == 'richness') %>%
  ggplot(aes(x = value, y = ..density.., fill = filter_level)) +
  geom_histogram(binwidth = 4, position = "identity", alpha = 0.5) +
  geom_density(alpha = 0.6) +
  facet_grid(section ~ type_simple + buffer, scale = "free") +
  theme_minimal() +
  custom_ggplot_theme +
  ggtitle("Density & Histogram: Samples based on their number of genomes depending on coverage filtering")

tidy_plot_alpha_diversity_genomes %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(metric == 'richness') %>%
  filter(value >0) %>%
  ggplot(aes(x = filter_level, fill = type)) +
  geom_bar() +   
  facet_grid(section ~ buffer, scale = "free") +
  theme_minimal() +
  custom_ggplot_theme +
  ggtitle("Number of samples with at least 1 genome present")

```

```{r plot_buffer_community_1, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  ggplot(aes(x = microsample, y = count, fill = phylum)) +
  geom_col(position = "fill", colour = "white", linewidth = 0.1) +
  scale_fill_manual(values = phylum_colors[-4], drop = FALSE) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Composition of bacterial phyla in the bacterial reads")
```


```{r plot_buffer_community_2, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
# Calculate total abundance for each phylum
phylum_order <- tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  group_by(phylum) %>%
  summarise(total_abundance = sum(count, na.rm = TRUE), .groups = "drop") %>%
  arrange(total_abundance) %>%
  pull(phylum) # Extract the ordered phylum names

# Convert 'phylum' to a factor with levels ordered by abundance
community_composition <- tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  mutate(phylum = factor(phylum, levels = phylum_order))

community_composition %>%
  ggplot(aes(x = microsample, y = count, fill = phylum)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = phylum_colors[-4], drop = FALSE) +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Composition of bacterial phyla in the bacterial reads")
```

NB! Colours & order not finished!!
```{r plot_buffer_community_3, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
# tidy_plot_genome_counts %>%
#   filter(!!!plot_params$filter_conditions) %>%
#   group_by(microsample, class) %>%
#   summarise(total_count = sum(count, na.rm = TRUE),
#             across(where(is.character), ~ first(.)),
#             .groups = "drop") %>%
#   ggplot(aes(x = microsample, y = total_count, fill = class)) +
#   geom_bar(stat = "identity", position = "stack") +
#   facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   custom_ggplot_theme 
```


### Genus level plot


NB! Colours & order not finished!!

NB! This will be changed!
```{r generate_shades_function, warning=FALSE, comments="", message=FALSE}
generate_shades <- function(base_color, n) {
  # Generate 'n' shades from the base color to a lighter version (not white)
  colorRampPalette(colors = c(scales::muted(base_color, l = 30), base_color))(n)
}
```

Function to generate plots based on taxonomy data and plot parameters. 
```{r plot_buffer_community_4, warning=FALSE, comments="", message=FALSE, fig.height=10, fig.width=15}
# Calculate total abundance for each phylum
phylum_order <- tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  group_by(phylum) %>%
  summarise(total_abundance = sum(count, na.rm = TRUE), .groups = "drop") %>%
  arrange(total_abundance) %>%
  pull(phylum) # Extract the ordered phylum names

# Convert 'phylum' to a factor with levels ordered by abundance
filtered_data <- tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
    group_by(microsample, genus) %>%
    summarise(total_count = sum(count, na.rm = TRUE),
            across(where(is.character), ~ first(.)),
            .groups = "drop") %>%
  mutate(phylum = factor(phylum, levels = phylum_order))

# Create an ordered factor for genus within each phylum by abundance
filtered_data <- filtered_data %>%
  group_by(phylum, genus) %>%
  summarise(genus_abundance = sum(total_count, na.rm = TRUE), .groups = "drop") %>%
  arrange(phylum, desc(genus_abundance)) %>%
  mutate(genus_order = factor(genus, levels = unique(genus))) %>%
  select(phylum, genus, genus_order) %>%
  right_join(filtered_data, by = c("phylum", "genus")) %>% # Rejoin to original filtered data
  mutate(
    genus_for_plot = genus_order, # Use the ordered factor for plotting
    genus_label = as.character(genus)) %>% # Keep original genus names for labeling
  select(-genus_order)

# Calculate total abundance for each genus across all phyla
genus_abundance <- filtered_data %>%
  group_by(genus) %>%
  summarise(total_abundance = sum(total_count, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(total_abundance))

# Get the top 'n' genera by overall abundance
top_genera <- genus_abundance %>%
  slice_head(n = 10) %>%
  pull(genus)

filtered_data <- filtered_data %>%
    mutate(genus_color = ifelse(genus %in% top_genera, as.character(phylum), "Other"), 
           genus_label = ifelse(genus %in% top_genera, paste(genus, "(", phylum, ")"), "Other"))

# Reorder 'genus_label' factor by genus abundance, using cleaned phylum names for display
filtered_data <- filtered_data %>%
  mutate(genus_label = factor(genus_label,levels = c(paste(sub("^g__", "", top_genera), "(", sub("^p__", "", filtered_data$phylum[match(top_genera, filtered_data$genus)]), ")"), "Other")
))

# Prepare the phylum colors
phylum_colors_named <- phylum_colors#[-4]
names(phylum_colors_named) <- levels(filtered_data$phylum)

# Generate color mapping for each genus within its phylum
color_mapping <- c()
for (phylum in unique(filtered_data$phylum)) {
  phylum_data <- filtered_data %>%
    filter(phylum == !!phylum & genus_label != "Other") %>%
    distinct(genus_label)

  n_genera <- nrow(phylum_data)
  phylum_color <- phylum_colors_named[phylum]

  if (n_genera > 0) {
    # Generate shades for each genus
    phylum_shades <- generate_shades(phylum_color, n_genera)
    names(phylum_shades) <- phylum_data$genus_label
    color_mapping <- c(color_mapping, phylum_shades)
  }
}

# Add grey color for 'Other' category
color_mapping["Other"] <- "grey"

# Generate the plot
ggplot(filtered_data, aes(x = microsample, y = total_count, fill = genus_label, group = interaction(phylum, genus_for_plot))) +
  geom_bar(stat = "identity", colour = "white", linewidth = 0.05) + # Stacked bars with white borders
  scale_fill_manual(values = color_mapping, drop = FALSE) + # Use manual color scale
  custom_ggplot_theme +
  facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  custom_ggplot_theme +
  ggtitle("Composition of bacterial phyla in the bacterial reads")

```

```{r plot_buffer_community_jitterplot, warning=FALSE, comments="", message=FALSE, fig.height=15, fig.width=15}
# Summarise relabun but keep only the grouping columns
filtered_data <- tidy_plot_genome_counts %>%
  filter(!!!plot_params$filter_conditions) %>%
  filter(type == 'Positive') %>%
  group_by(microsample, phylum, genus) %>%
  summarise(relabun = sum(count), ,
            across(where(is.character), ~ first(.)),
            .groups = 'drop')

summary <- filtered_data %>%
  group_by(genus) %>%
  summarise(mean = geometric.mean(relabun, na.rm = T)) %>% #geometric mean because it is a %
  arrange(-mean)

# Reorder taxon_level based on the summary
filtered_data %>%
  mutate(genus = factor(genus, levels = rev(summary %>% pull(genus))))  %>%
  ggplot(aes(x = relabun, y = genus, group = genus, color = phylum)) +
    scale_color_manual(values = phylum_colors) +
    geom_jitter(alpha = 0.3, size=0.5) +
    facet_nested(. ~ section + type + buffer, scales = "free", space = "free", switch = "y") +
    theme_minimal() +
    custom_ggplot_theme + 
    scale_x_continuous(limits = c(0, 1))

```




<!--chapter:end:4_buffer_experiment.Rmd-->


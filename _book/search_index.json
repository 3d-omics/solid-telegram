[["index.html", "3D’omics | Avian microbiome - Methods MSSM manuscript Work in progress Chapter 1 Introduction 1.1 Prepare the R environment 1.2 Notes:", " 3D’omics | Avian microbiome - Methods MSSM manuscript Work in progress Antton Alberdi1 Amalia Bogri2 Carlotta Pietroni3 Jorge Langa4 2024-12-17 Chapter 1 Introduction This webbook contains all the code used for the analyses of the MSSM methods manuscript. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/3d-omics/ANMI014_chicken_LMD_methods.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(devtools) library(tinytable) library(broom) library(broom.mixed) library(rairtable) library(jsonlite) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(jpeg) library(patchwork) # For statistics library(spaa) library(vegan) library(Rtsne) library(geiger) library(hilldiv2) library(distillR) library(ANCOMBC) library(lme4) library(Hmsc) library(psych) # For compositional analyses library(zCompositions) library(compositions) # Tidyverse libraries (load dplyr last to avoid conflicts) library(tidyverse) library(dplyr) # Explicitly load dplyr last 1.2 Notes: 1.2.1 Installation of modules Most of the modules can be downloaded from CRAN with ‘install.packages(’XXX’, dependencies = TRUE)‘. Four modules are from Bioconductor. Install with: ’install.packages(’BiocManager’, dependencies = TRUE) BiocManager::install(c(“phyloseq”, “ggtreeExtra”,“ggtree”,“ANCOMBC”))’ Two modules are from Antton’s github. Install with: ‘install.packages(’remotes’, dependencies = TRUE) remotes::install_github(‘anttonalberdi/hilldiv2’) remotes::install_github(‘anttonalberdi/distillR’)’ 1.2.2 Airtable access: Currently the metadata is loaded from the 3D’omics airtable. In order to access it you need your own API key (from Antton). set_airtable_api_key(‘XXXXX’, install = TRUE) University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ University of Copenhagen, amalia.bogri@sund.ku.dk↩︎ University of Copenhagen, carlotta.pietroni@sund.ku.dk↩︎ University of Copenhagen, jorge.langa@sund.ku.dk↩︎ "],["data-import.html", "Chapter 2 Data Import 2.1 Bacterial reads (counts) data 2.2 Genome covered bases data 2.3 Genome (MAGs) metadata 2.4 Sample metadata 2.5 Sequencing statistics data 2.6 Bacterial phyla color scheme data 2.7 Filter and normalise data 2.8 Wrap working objects", " Chapter 2 Data Import 2.1 Bacterial reads (counts) data Import the count tables from ERDA. All files were produced with Reference MAG catalogue 009. In the next version, we will fetch only one file with all the counts from all batches. And it might be a json file containing all needed tsv files. Questions: - MSEB0009 has a column ‘undetermined’. Why? Answer: it comes from Novogene. There are more than one columns for each sample. MSEB0006, MSEB0011, MSEB0012, MSEB0014, MSEB0015 - have no repetitions of samples MSEB0009 - some samples are there twice (reaching up to .lib2) MSEB0010 - some samples are there 6 or 7 times (reaching up to .lib6 or .lib7) Answer: it comes from Novogene resequencing those batches multiple times. Found it with: group_by(genome, sample) %&gt;% count() %&gt;% # Get group sizes group_by(n) %&gt;% # Group by the size of each group summarise(frequency = n(), .groups = “drop”) # Count occurrences of each group size read_counts &lt;- read_tsv( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE) %&gt;% # MSEB0006 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0009 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0010 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0011 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0012 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0014 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.count.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0015 rename(genome = 1) %&gt;% # rename first column to &#39;genome&#39; pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% # pivot to a long 2-column table (columns: data, counts) mutate(sample = substr(data, 1, 7)) %&gt;% # make new column (&#39;sample&#39;) from column &#39;data&#39;, by keeping the first 7 characters - i.e. remove the .lib1 ending filter(grepl(&quot;^M&quot;, sample)) %&gt;% # filter to only keep microsamples starting from M (so, remove the &#39;undetermined&#39; ) group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% # sum counts from same genome-sample group (i.e. for MSEB0009 &amp; MSEB0010) pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) # make table wide again (i.e. columns become sample) 2.2 Genome covered bases data Same comments &amp; questions as for count tables! This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. genome_covered_bases &lt;- read_tsv(&quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE) %&gt;% # MSEB0006 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0009 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0010 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0011 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0012 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0014 left_join(read_tsv(&quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/results/quantify/coverm/coverm_genome_REF0009-mgg-pbdrep.covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% # MSEB0015 rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) %&gt;% select(-Undeter) 2.3 Genome (MAGs) metadata Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses. The number of genomes in these files matches the number of genomes in the count tables. So, I assume that Antton has downloaded/provided the files for REF0009. But, I could not find the relevant files in ERDA&gt;3D’omics&gt;references&gt;REF0009-mggp. 2.3.1 Genome (MAGs) taxonomy This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses. genome_taxonomy &lt;- read_tsv(&quot;data/genome_taxonomy.tsv&quot;, show_col_types = FALSE) %&gt;% rename(genome = user_genome) %&gt;% # rename first column mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% # remove .fa from the end of each genome name separate(classification, c(&quot;domain&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;), sep = &quot;;&quot;) %&gt;% # separate column &#39;classification&#39; into columns for the different taxonomic levels mutate(across(domain:species, ~ str_sub(., 4))) %&gt;% # remove reduntant letters before taxon names select(genome, domain, phylum, class, order, family, genus, species) %&gt;% # select the relevant columns arrange(match(genome, read_counts$genome)) # reorder the rows of taxonomy df based on the order of the read_counts df 2.3.2 Genome (MAGs) quality Quality properties of the genomes. genome_quality &lt;- read_tsv(&quot;data/genome_quality.tsv&quot;, show_col_types = FALSE) %&gt;% rename(genome = 1) %&gt;% # rename first column mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% # remove .fa from the end of each genome name arrange(match(genome, read_counts$genome)) %&gt;% # reorder the rows of taxonomy df based on the order of the read_counts df select(genome, Completeness, Contamination, Coding_Density, Genome_Size) %&gt;% # select relevant columns rename(completeness = Completeness, contamination = Contamination, coding_density = Coding_Density, length = Genome_Size) # rename columns 2.3.3 Merged Genome (MAGs) taxonomy &amp; quality Merge taxonomy, length and quality information genome_metadata &lt;- genome_taxonomy %&gt;% left_join(genome_quality, by = join_by(genome == genome)) # join quality 2.3.4 Genome (MAGs) tree This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes. genome_tree &lt;- read.tree(&quot;data/genome_tree.tre&quot;) genome_tree$tip.label &lt;- str_replace_all(genome_tree$tip.label, &quot;&#39;&quot;, &quot;&quot;) # remove single quotes in MAG names genome_tree &lt;- keep.tip(genome_tree, tip = read_counts$genome) # keep only MAG tips 2.3.5 Genome (MAGs) functional annotations This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR. genome_annotations &lt;- read_tsv(&quot;data/genome_annotations.tsv.xz&quot;, show_col_types = FALSE) %&gt;% rename(gene = 1, genome = 2) 2.3.6 Distil functional annotations Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses. genome_gifts &lt;- distill(genome_annotations, GIFT_db, genomecol = 2, annotcol = c(9, 10, 19)) 2.4 Sample metadata Import sample metadata from the airtable. sample_metadata &lt;- airtable(&quot;4-MSE-Info&quot;, &quot;appKakM1bnKSekwuW&quot;) %&gt;% # get base ID from Airtable browser URL read_airtable(., fields = c( &quot;ID&quot;, &quot;LabBatch_text&quot;, &quot;IntestinalSection&quot;, &quot;SampleType&quot;, &quot;Xcoord&quot;, &quot;Ycoord&quot;, &quot;SizeApprox&quot;, &quot;cryosection_text&quot;, &quot;buffer_text&quot;, &quot;Collection_Success&quot;, &quot;Collection_attempts&quot;, &quot;UsedCycles&quot;, &quot;animal_temp&quot;, &quot;Protocol_text&quot;, &quot;Collection_method_text&quot; ), id_to_col = TRUE) %&gt;% filter(LabBatch_text %in% c(&quot;MSEB0006&quot;, &quot;MSEB0009&quot;, &quot;MSEB0010&quot;, &quot;MSEB0011&quot;, &quot;MSEB0012&quot;, &quot;MSEB0014&quot;, &quot;MSEB0015&quot;)) %&gt;% rename( batch = LabBatch_text, microsample = ID, section = IntestinalSection, type = SampleType, cryosection = cryosection_text, buffer = buffer_text, collection = Collection_Success, collection_attempts = Collection_attempts, cycles = UsedCycles, animal = animal_temp, size = SizeApprox, protocol = Protocol_text, collection_method = Collection_method_text ) %&gt;% select( microsample, section, type, batch, cryosection, buffer, Xcoord, Ycoord, size, collection, collection_attempts, cycles, animal, protocol, collection_method ) %&gt;% unnest(c(section, Xcoord, Ycoord, size, collection, cycles, collection_method)) %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) %&gt;% mutate(type_simple = substr(type, 1, 1)) %&gt;% arrange(microsample) 2.5 Sequencing statistics data For the analysis of different batches mapped to reference REF009, I define lists with the names of the files required for the statistics. The files were produced by Jorge’s bioinformatics pipeline (g_mg), and located in 3D’omics ERDA. Then, I import the relevant columns of each file with a loop, through a function. I use a function to avoid creating intermediate dataframes for each statistic. I use all the functions at the end to create the general statistics table. 2.5.1 Sequencing statistics before trimming Used the multiqc_fastqc.txt because the multiqc_general_stats.txt did not exist in all batches. stats_before_trim_file_list &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/reads_data/multiqc_fastqc.txt&quot; # MSEB0015 ) stats_before_trim_load_function &lt;- function(file) { read_tsv(file, col_types = cols_only( &quot;Sample&quot; = col_character(), # define the type of column (text, numbers, etc.) &quot;Total Sequences&quot; = col_double(), &quot;%GC&quot; = col_double(), &quot;total_deduplicated_percentage&quot; = col_double() ), show_col_types = FALSE # ask R not to print out the type of each column ) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% # extract sample name starting from &quot;M&quot; with numbers that follow M. Different names will turn to &quot;&#39;&quot;NA&quot; rename( # rename columns microsample = Sample, total_sequences_before_trim = `Total Sequences`, percent_gc_before_trim = `%GC`, percent_unique_before_trim = total_deduplicated_percentage ) %&gt;% select(microsample, total_sequences_before_trim, percent_gc_before_trim, percent_unique_before_trim) } # apply the function to all files in the list, then bind all the tables together stats_before_trim &lt;- bind_rows(lapply(stats_before_trim_file_list, stats_before_trim_load_function)) %&gt;% group_by(microsample) %&gt;% # because there are at least two rows per sample in the multi_fastqc files. summarise( total_sequences_before_trim = sum(total_sequences_before_trim, na.rm = TRUE), # sum the no. of sequences in the rows of each sample percent_gc_before_trim = mean(percent_gc_before_trim, na.rm = TRUE), # mean of GC% for the two rows. Only works when the no.of sequences is the same in the two rows -&gt; Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010) percent_unique_before_trim = mean(percent_unique_before_trim, na.rm = TRUE) # mean of unique% for the two rows. Only works when the no.of sequences is the same in the two rows -&gt; Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010) ) 2.5.2 Sequencing statistics after trimming stats_after_trim_file_list &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot; # MSEB0015 ) stats_after_trim_load_function &lt;- function(file) { read_tsv(file, col_types = cols_only( &quot;Sample&quot; = col_character(), # define the type of column (text, numbers, etc.) &quot;Total Sequences&quot; = col_double(), &quot;%GC&quot; = col_double(), &quot;total_deduplicated_percentage&quot; = col_double() ), show_col_types = FALSE # ask R not to print out the type of each column ) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% # extract sample name starting from &quot;M&quot; with numbers that follow M. Different names will turn to &quot;&#39;&quot;NA&quot; rename( # rename columns microsample = Sample, total_sequences_after_trim = `Total Sequences`, percent_gc_after_trim = `%GC`, percent_unique_after_trim = total_deduplicated_percentage ) %&gt;% select(microsample, total_sequences_after_trim, percent_gc_after_trim, percent_unique_after_trim) } # apply the function to all files in the list, then bind all the tables together stats_after_trim &lt;- bind_rows(lapply(stats_after_trim_file_list, stats_after_trim_load_function)) %&gt;% group_by(microsample) %&gt;% # because there are at least two rows per sample in the multi_fastqc files. summarise( total_sequences_after_trim = sum(total_sequences_after_trim, na.rm = TRUE), # sum the no. of sequences in the rows of each sample percent_gc_after_trim = mean(percent_gc_after_trim, na.rm = TRUE), # mean of GC% for the two rows. Only works when the no.of sequences is the same in the two rows -&gt; Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010) percent_unique_after_trim = mean(percent_unique_after_trim, na.rm = TRUE) # mean of unique% for the two rows. Only works when the no.of sequences is the same in the two rows -&gt; Not accurate for samples that have been resequenced (MSEB0009 and MSEB0010) ) Two rows are missing after trimming. Which ones? M300703 from MSEB0009 M300723 from MSEB0010 anti_join(stats_before_trim, stats_after_trim, by = &quot;microsample&quot;) 2.5.3 Non-bacterial mapped reads: human,chicken, swine This is calculated on the trimmed reads. The reads are mapped to 3 databases (1. human (GRCh38), 2. chicken (GRCg7b), 3. pig (Sscrofa11.1)) sequentially. From file ‘multiqc_samtools_flagstat’: To find the number of reads mapped to each reference you have to either - sum the columns: ‘mapped_passed’ and ‘singletons_passed’ OR - subtract the number of reads that entered the analysis (e.g. column ‘total_passed’ of human - from column ‘total_passed’ of chicken = reads mapped to human). If you try both, these numbers should be equal. After the final analysis, the plan is to get one count table with all these numbers (together with bacteria, and not mapped). non_bacteria_mapping_files_list &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot; # MSEB0015 ) non_bacteria_mapping_load_function &lt;- function(file) { read_tsv(file, show_col_types = FALSE) %&gt;% mutate(reference = case_when( grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, grepl(&quot;Sscrofa11.1&quot;, Sample, ignore.case = TRUE) ~ &quot;swine&quot;, TRUE ~ NA_character_ )) %&gt;% mutate( microsample = str_extract(Sample, &quot;M\\\\d+&quot;), chicken_total_passed = ifelse(reference == &quot;chicken&quot;, total_passed, NA_real_), human_total_passed = ifelse(reference == &quot;human&quot;, total_passed, NA_real_), swine_total_passed = ifelse(reference == &quot;swine&quot;, total_passed, NA_real_), chicken_mapped_passed = ifelse(reference == &quot;chicken&quot;, mapped_passed, NA_real_), human_mapped_passed = ifelse(reference == &quot;human&quot;, mapped_passed, NA_real_), swine_mapped_passed = ifelse(reference == &quot;swine&quot;, mapped_passed, NA_real_), chicken_singletons_passed = ifelse(reference == &quot;chicken&quot;, singletons_passed, NA_real_), human_singletons_passed = ifelse(reference == &quot;human&quot;, singletons_passed, NA_real_), swine_singletons_passed = ifelse(reference == &quot;swine&quot;, singletons_passed, NA_real_), chicken_total_mapped = ifelse(reference == &quot;chicken&quot;, mapped_passed + singletons_passed, NA_real_), human_total_mapped = ifelse(reference == &quot;human&quot;, mapped_passed + singletons_passed, NA_real_), swine_total_mapped = ifelse(reference == &quot;swine&quot;, mapped_passed + singletons_passed, NA_real_), swine_unmapped = ifelse(reference == &quot;swine&quot;, swine_total_passed - swine_total_mapped, NA_real_) ) %&gt;% select(microsample, chicken_total_passed, human_total_passed, swine_total_passed, chicken_mapped_passed, human_mapped_passed, swine_mapped_passed, chicken_singletons_passed, human_singletons_passed, swine_singletons_passed, chicken_total_mapped, human_total_mapped, swine_total_mapped, swine_unmapped) %&gt;% group_by(microsample) %&gt;% summarise(across(starts_with(&quot;chicken_&quot;) | starts_with(&quot;human_&quot;) | starts_with(&quot;swine_&quot;), sum, na.rm = TRUE)) } stats_non_bacteria_mapping &lt;- bind_rows(lapply(non_bacteria_mapping_files_list, non_bacteria_mapping_load_function)) 2.5.4 Bacterial mapped reads This is calculated on the trimmed reads after filtering for human, chicken, and pig reads. ‘Unmapped reads’ at this point are trimmed but not mapped to human, chicken, pig, or bacterial MAG catalogue. bacteria_mapping_files_list &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot; # MSEB0015 ) bacteria_mapping_load_function &lt;- function(file) { read_tsv(file, show_col_types = FALSE) %&gt;% filter(str_detect(Sample, &quot;mgg-pbdrep&quot;)) %&gt;% #select samples mapped to REF0009-gg-pbdrep database (i.e. NO &#39;salmonella&#39; or &#39;chicken big mag&#39;) mutate( microsample = str_extract(Sample, &quot;M\\\\d+&quot;), bacteria_total_passed = raw_total_sequences, bacteria_total_mapped = reads_mapped, unmapped = reads_unmapped ) %&gt;% group_by(microsample) %&gt;% summarise( bacteria_total_passed = sum(bacteria_total_passed, na.rm = TRUE), # because some samples were sequence multiple times bacteria_total_mapped = sum(bacteria_total_mapped, na.rm = TRUE), unmapped = sum(unmapped, na.rm = TRUE) ) %&gt;% select(microsample, bacteria_total_passed, bacteria_total_mapped, unmapped) } stats_bacteria_mapping &lt;- bind_rows(lapply(bacteria_mapping_files_list, bacteria_mapping_load_function)) Alternative way to estimate bacterial read counts (from count table): # Transpose the table stats_bacteria_mapping_alternative &lt;- read_counts %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% # Move genome names to rownames t() %&gt;% # Transpose the data as.data.frame() %&gt;% # Convert back to a data frame rownames_to_column(var = &quot;microsample&quot;) %&gt;% # Move sample names into a column mutate(bacteria_total_read_counts = rowSums(select(., -microsample))) %&gt;% # sum the counts of all genomes in each sample (i.e. sum of each row) select(microsample, bacteria_total_read_counts)%&gt;% # choose to show only the total_counts column filter(grepl(&quot;^M&quot;, microsample)) # choose only microsamples starting with &#39;M&#39; (i.e. not the &#39;undetermined&#39;) 2.5.5 Combine relevant sequencing statistics stats_combined &lt;- reduce(list(stats_before_trim, stats_after_trim, stats_non_bacteria_mapping, stats_bacteria_mapping, stats_bacteria_mapping_alternative), full_join, by = &quot;microsample&quot;) %&gt;% filter(grepl(&quot;^M&quot;, microsample)) %&gt;% mutate(removed_sequences_after_trim = total_sequences_before_trim - total_sequences_after_trim) %&gt;% select(microsample, total_sequences_before_trim, total_sequences_after_trim, removed_sequences_after_trim, percent_gc_before_trim, percent_gc_after_trim, percent_unique_before_trim, percent_unique_after_trim, chicken_total_mapped, human_total_mapped, swine_total_mapped, bacteria_total_mapped, bacteria_total_read_counts, unmapped ) Estimate some percentages - maybe this is not needed for plotting. Estimate the quality score of each sample, and add as a new column. This is optional and will be updated with a better estimation of quality. final_combined_stats &lt;- stats_combined %&gt;% mutate( trimmed_percentage = ((total_sequences_before_trim-total_sequences_after_trim)/total_sequences_before_trim)*100, human_percentage = (human_total_mapped/total_sequences_after_trim)*100, chicken_percentage = (chicken_total_mapped/total_sequences_after_trim)*100, swine_percentage = (swine_total_mapped/total_sequences_after_trim)*100, bacteria_percentage = (bacteria_total_mapped/total_sequences_after_trim)*100, unmapped_percentage = (unmapped/total_sequences_after_trim)*100, depth = ifelse(total_sequences_after_trim &gt; 1000000, 1, 0), duplicates = ifelse(percent_unique_after_trim &gt; 30, 1, 0), gc = ifelse(percent_gc_after_trim &lt; 60, 1, 0), human = ifelse(human_percentage &lt; 5, 1, 0), bacteria = ifelse(bacteria_percentage &gt; 75, 1, 0), quality = depth + duplicates + gc + human + bacteria ) 2.6 Bacterial phyla color scheme data AlberdiLab projects use unified color schemes developed for the Earth Hologenome Initiative, to facilitate figure interpretation. phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;, show_col_types = FALSE) %&gt;% mutate(phylum = gsub(&quot;^p__&quot;, &quot;&quot;, phylum)) %&gt;% right_join(genome_metadata, by = join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% pull(colors, name = phylum) 2.7 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. 2.7.1 Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. genome_coverage &lt;- genome_covered_bases %&gt;% mutate(across(where(is.numeric), ~ . / genome_metadata$length)) 2.7.2 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. min_coverage &lt;- 0.3 read_counts_filt_30 &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% # turn entries of &lt;0.3 to 0, keep the rest to 1 mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1) min_coverage &lt;- 0.2 read_counts_filt_20 &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% # turn entries of &lt;0.3 to 0, keep the rest to 1 mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1) min_coverage &lt;- 0.1 read_counts_filt_10 &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% # turn entries of &lt;0.3 to 0, keep the rest to 1 mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1) min_coverage &lt;- 0.05 read_counts_filt_05 &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% # turn entries of &lt;0.3 to 0, keep the rest to 1 mutate(across(-1, ~ . * read_counts[[cur_column()]])) # to all columns except first (genomes), multiply read_counts with the number (0 or 1) 2.7.3 Generate genome count table Read counts are transformed into genome counts using genome-length and read-length information. Explanation: Read counts are influenced by sequencing depth and genome size. Larger genomes will naturally attract more reads than smaller ones, even if their actual abundance is the same. By normalizing read counts to genome size, genome counts provide a size-independent estimate of how many genome copies (or organisms carrying that genome) are present in a sample. readlength &lt;- 150 # change if sequencing read length is different # Reads without low-coverage filtering: genome_counts &lt;- read_counts %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) #Reads after filtering the low-coverage reads: genome_counts_filt_30 &lt;- read_counts_filt_30 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) genome_counts_filt_20 &lt;- read_counts_filt_20 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) genome_counts_filt_10 &lt;- read_counts_filt_10 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) genome_counts_filt_05 &lt;- read_counts_filt_05 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) 2.8 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(genome_counts, genome_counts_filt_30, genome_counts_filt_20, genome_counts_filt_10, genome_counts_filt_05, genome_tree, genome_metadata, genome_gifts, sample_metadata, phylum_colors, final_combined_stats, file = &quot;data/data.Rdata&quot; ) read_counts: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table. genome_counts: Number of genomes quantified in each sample, calculated through filtering and normalising read_counts. This is the community composition table to be used in downstream analyses unless otherwise stated. genome_tree: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses. genome_metadata: Taxonomic and quality information of the genomes. sample_metadata: Treatment/population and other relevant metadata of the samples. "],["data-preparation-for-plotting.html", "Chapter 3 Data preparation for plotting 3.1 Load the data that were prepared in the previous chapter. 3.2 Sequencing statistics dataframes 3.3 Count tables dataframes 3.4 Alpha diversity dataframes 3.5 Wrap working objects", " Chapter 3 Data preparation for plotting 3.1 Load the data that were prepared in the previous chapter. load(&quot;data/data.Rdata&quot;) 3.2 Sequencing statistics dataframes plot_data_stats &lt;- final_combined_stats %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) Make tidy table for sequencing stats before &amp; after trimming tidy_plot_data_stats_before_after &lt;- plot_data_stats %&gt;% pivot_longer( cols = c( total_sequences_before_trim, total_sequences_after_trim, percent_gc_before_trim, percent_gc_after_trim, percent_unique_before_trim, percent_unique_after_trim ), names_to = c(&quot;Metric&quot;, &quot;Condition&quot;), # Split column names names_pattern = &quot;(.*)_(before|after)_trim&quot; ) %&gt;% pivot_wider( names_from = Metric, values_from = value ) %&gt;% mutate( Condition = factor(Condition, levels = c(&quot;before&quot;, &quot;after&quot;))) Make tidy table for counts category_counts &lt;- tibble::tibble( category = c( &quot;bacteria_total_mapped&quot;, &quot;chicken_total_mapped&quot;, &quot;human_total_mapped&quot;, &quot;swine_total_mapped&quot;, &quot;unmapped&quot;, &quot;removed_sequences_after_trim&quot;), label = c(&quot;Bacteria&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;), color = c( &quot;#B92D65&quot;, &quot;#E8BD50&quot;, &quot;#1092b4&quot;, &quot;#3baf6f&quot;, &quot;#8d98ae&quot;, &quot;#2b2d42&quot;)) tidy_plot_data_stats_counts &lt;- plot_data_stats %&gt;% pivot_longer( cols = c( chicken_total_mapped, human_total_mapped, swine_total_mapped, bacteria_total_mapped, unmapped, removed_sequences_after_trim), names_to = &quot;mapping_status&quot;, values_to = &quot;counts&quot;) %&gt;% left_join(category_counts, by = c(&quot;mapping_status&quot; = &quot;category&quot;)) %&gt;% mutate( # order the groups in desired order label = factor(label, levels = c(&quot;Bacteria&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;))) # Set labels &amp; colours as colour palette color_palette_tidy_plot_data_stats_counts &lt;- setNames(category_counts$color, category_counts$label) 3.3 Count tables dataframes Make tidy tables for genome counts tidy_plot_genome_counts &lt;- genome_counts %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% # scale each sample to 1 pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% # Flatten section if it&#39;s a list filter(count &gt; 0) # Filter out rows with count &lt;= 0 (that are redundant after pivot_longer, but important for b div) And then do the same for filtered counts at different coverage thresholds tidy_plot_genome_counts_filt_05 &lt;- genome_counts_filt_05 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) tidy_plot_genome_counts_filt_10 &lt;- genome_counts_filt_10 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) tidy_plot_genome_counts_filt_20 &lt;- genome_counts_filt_20 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) tidy_plot_genome_counts_filt_30 &lt;- genome_counts_filt_30 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) 3.4 Alpha diversity dataframes Define function to estimate the genomes’ alpha diversity measurements from genome counts. calculate_alpha_diversity &lt;- function(input_data, dataset_name) { # Step 1: Transform the input data (remove rownames if needed) input_data_matrix &lt;- input_data %&gt;% column_to_rownames(var = &quot;genome&quot;) # Step 2: Calculate richness (q = 0) richness &lt;- hilldiv(input_data_matrix, q = 0) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(richness = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 3: Calculate neutral diversity (q = 1) neutral &lt;- hilldiv(input_data_matrix, q = 1) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(neutral = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 4: Calculate phylogenetic diversity (q = 1, with genome tree) phylogenetic &lt;- hilldiv(input_data_matrix, q = 1, tree = genome_tree) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(phylogenetic = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 5: Merge all diversity metrics alpha_diversity &lt;- richness %&gt;% full_join(neutral, by = &quot;microsample&quot;) %&gt;% full_join(phylogenetic, by = &quot;microsample&quot;) # %&gt;% # left_join(sample_metadata, by = &quot;microsample&quot;) %&gt;% # left_join(final_combined_stats, by = &quot;microsample&quot;) %&gt;% # Return the alpha_diversity data frame return(alpha_diversity) } Estimate the alpha diversity on the unfiltered and the coverage-filtered counts alpha_div_unfiltered &lt;- calculate_alpha_diversity( input_data = genome_counts, dataset_name = &quot;unfiltered&quot;) %&gt;% mutate(filter_level = &quot;unfiltered&quot;) alpha_div_filtered_05 &lt;- calculate_alpha_diversity( input_data = genome_counts_filt_05, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_05&quot;) alpha_div_filtered_10 &lt;- calculate_alpha_diversity( input_data = genome_counts_filt_10, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_10&quot;) alpha_div_filtered_20 &lt;- calculate_alpha_diversity( input_data = genome_counts_filt_20, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_20&quot;) alpha_div_filtered_30 &lt;- calculate_alpha_diversity( input_data = genome_counts_filt_30, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_30&quot;) alpha_diversity &lt;- bind_rows( alpha_div_unfiltered, alpha_div_filtered_05, alpha_div_filtered_10, alpha_div_filtered_20, alpha_div_filtered_30) %&gt;% left_join(sample_metadata, by = &quot;microsample&quot;) %&gt;% left_join(final_combined_stats, by = &quot;microsample&quot;) %&gt;% mutate(filter_level = factor(filter_level, levels = c(&quot;unfiltered&quot;, &quot;filtered_05&quot;, &quot;filtered_10&quot;, &quot;filtered_20&quot;, &quot;filtered_30&quot;))) Make tidy a-diversity tidy_plot_alpha_diversity_genomes &lt;- alpha_diversity %&gt;% pivot_longer( cols = c(richness, neutral, phylogenetic), names_to = &quot;metric&quot;, values_to = &quot;value&quot; ) %&gt;% mutate(metric = factor(metric, levels = c(&quot;richness&quot;, &quot;neutral&quot;, &quot;phylogenetic&quot;))) 3.5 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(plot_data_stats, tidy_plot_data_stats_before_after, tidy_plot_data_stats_counts, color_palette_tidy_plot_data_stats_counts, tidy_plot_genome_counts, tidy_plot_genome_counts_filt_05, tidy_plot_genome_counts_filt_10, tidy_plot_genome_counts_filt_20, tidy_plot_genome_counts_filt_30, tidy_plot_alpha_diversity_genomes, phylum_colors, file = &quot;data/plot_data.Rdata&quot; ) "],["list-of-experiments.html", "Chapter 4 List of experiments", " Chapter 4 List of experiments Define lists that contain the plot settings for different experiments 4.0.1 B11 vs B12 lysis buffers Compare buffer B11 and B12. Use batches MSEB0006 (caecum) and MSEB0010 (colon), from the focal (adult) chicken. For the colon, use the samples that were amplified with 15 PCR cycles instead of 19 (due to the latter’s low quality). plot_params_buffers &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(cycles &lt; 16), quote(batch == &quot;MSEB0006&quot; | batch == &quot;MSEB0010&quot;) ), labels_title = &quot;Lysis Buffer&quot;, facet_formula = &quot;. ~ section + type + buffer&quot;, #&quot;batch + section + type ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;), fill_var = &quot;buffer&quot;, plot_title = &quot;Lysis Buffer trial&quot; ) 4.0.1.1 15 vs 19 PCR cycles Use the colon samples (MSEB0010). Maybe separate by buffer?? plot_params_cycles &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0010&quot;) ), labels_title = &quot;PCR cycles&quot;, facet_formula = &quot;section + type + cycles ~ .&quot;, # &quot;batch + section + type ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#e56969&#39;), fill_var = &quot;factor(cycles)&quot;, plot_title = &quot;PCR cycles trial&quot; ) 4.0.1.2 Limit of detection trial: Different LMD sizes Use batch MSEB0014 (caecum). plot_params_LOD &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0014&quot;) ), labels_title = &quot;LMD size&quot;, facet_formula = &quot;type + size ~ .&quot;, #&quot;batch + section + type + cryosection ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))&quot;, plot_title = &quot;Limit of detection (LMD size)&quot; ) 4.0.1.3 Automation trial Compare library prep with DreamPrep (MSEB0015) vs manual (MSEB0011) for ceacum of focal chicken plot_params_automation &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0015&quot;), quote(animal == &#39;G121e&#39;) ), labels_title = &quot;Automation&quot;, facet_formula = &quot;batch + type + cryosection ~ .&quot;, #&quot;batch + section + type + cryosection ~ .&quot; scale_fill_manual_val = c(&#39;#e56969&#39;,&#39;#c1558b&#39;), fill_var = &quot;batch&quot;, plot_title = &quot;Automation test&quot; ) 4.0.1.4 Full vs. half reaction (library prep with UltraLowV2 Tecan kit) Compare library prep with full reaction (MSEB0006, MSEB0009, MSEB0010) vs half reaction (MSEB0011, MSEB0012) of focal chicken, ceacum and colon (only low PCR cycles). NB! both buffers. plot_params_protocol &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;&amp; batch != &quot;MSEB0015&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16) ), labels_title = &quot;Protocol&quot;, facet_formula = &quot;type + section + protocol ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#c1558b&#39;,&#39;#8a49a1&#39;), fill_var = &quot;protocol&quot;, plot_title = &quot;Full vs. half reactions&quot; ) 4.0.1.5 Ceacum vs colon Compare colon vs caecum samples of the focal chicken (and only low PCR cycles) plot_params_section &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch == &quot;MSEB0009&quot;|batch == &quot;MSEB0010&quot;|batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16) ), labels_title = &quot;Section&quot;, facet_formula = &quot;type + section ~ .&quot;, #&quot;type+ batch ~ .&quot; scale_fill_manual_val = c(&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;section&quot;, plot_title = &quot;Caecum vs colon&quot; ) 4.0.1.6 Adult vs young chicken Compare samples from the focal (adult) chicken vs the younger chicken, for both colon (MSEB0012) and caecum (MSEB0011). plot_params_animal &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) ), labels_title = &quot;Animal&quot;, facet_formula = &quot;type + section + animal ~ .&quot;, #&quot;type+ batch + section + animal ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#c1558b&#39;), fill_var = &quot;animal&quot;, plot_title = &quot;Adult vs young chicken&quot; ) 4.0.1.7 LMD collection attemps Compare samples coloured by the number of attempts to collect the LMD sample. LOD trial excluded. plot_params_collection_attempts &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16), quote(collection_attempts&gt;0) ), labels_title = &quot;Collection attempts&quot;, facet_formula = &quot;type + section + collection_attempts ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;factor(collection_attempts)&quot;, plot_title = &quot;LMD collection attempts&quot; ) 4.0.1.8 LMD collection success Compare samples coloured by the LMD success jugded upon visual inspection of the collection lids. LOD trial excluded. plot_params_collection_success &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16), quote(collection_attempts&gt;0) ), labels_title = &quot;Collection_success&quot;, facet_formula = &quot;type + section + collection ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;collection&quot;, plot_title = &quot;LMD collection success&quot; ) 4.0.1.9 LMD collection container Compare samples coloured by the container they were collected in during the microsection. plot_params_container_collection &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch == &quot;MSEB0009&quot;), quote(cycles&lt;16), quote(protocol == &quot;ULV2_Full&quot;) ), labels_title = &quot;Collection_container&quot;, facet_formula = &quot;type + collection_method ~ .&quot;, scale_fill_manual_val = c(&#39;#c1558b&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;collection_method&quot;, plot_title = &quot;LMD collection container&quot; ) 4.0.1.10 Sections of Ceacum vs colon Compare colon vs caecum samples of the focal chicken (and only low PCR cycles) plot_params_slices &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16) ), labels_title = &quot;Section&quot;, facet_formula = &quot;type + section + cryosection ~ .&quot;, #&quot;type+ batch ~ .&quot; scale_fill_manual_val = c(&#39;#e56969&#39;,&#39;#8a49a1&#39;), fill_var = &quot;section&quot;, plot_title = &quot;Caecum vs colon&quot; ) 4.0.2 Define a list of all the experiments/trials settings that you want to plot. plot_params_list &lt;- list( plot_buffers = plot_params_buffers, plot_cycles = plot_params_cycles, plot_LOD = plot_params_LOD, plot_automation = plot_params_automation, plot_protocol = plot_params_protocol, plot_section = plot_params_section, plot_animal = plot_params_animal, plot_collection_attempts = plot_params_collection_attempts, plot_collection_success = plot_params_collection_success, plot_container_collection = plot_params_container_collection, plot_slices = plot_params_slices ) 4.0.3 Define lists that contain the settings for plotting each statistic. 4.0.3.1 Sequencing depth This is the total number of sequenced reads. stat_params_total_sequences &lt;- list( x_var = &quot;total_sequences&quot;, x_label = &quot;Number of reads&quot;, x_vline = 10000000, stacked = FALSE ) 4.0.3.2 Number of sequences after trimming This is the total number of sequenced reads after trimming the adaptors and low quality sequences. stat_params_trimmed_sequences &lt;- list( x_var = &quot;total_trimmed_sequences&quot;, x_label = &quot;Number of trimmed reads&quot;, x_vline = NULL, stacked = FALSE ) 4.0.3.3 Number of trimmed sequences This is the difference between total reads and reads after trimming. prepare_stacked_data &lt;- function(data) { data %&gt;% mutate(trimmed_reads = total_sequences - total_trimmed_sequences) %&gt;% pivot_longer(cols = c(total_trimmed_sequences, trimmed_reads), names_to = &quot;read_type&quot;, values_to = &quot;reads&quot;) %&gt;% mutate(read_type = factor(read_type, levels = c(&quot;trimmed_reads&quot;, &quot;total_trimmed_sequences&quot;))) } stat_params_compare_sequences &lt;- list( x_var = &quot;total_trimmed_sequences&quot;, x_label = &quot;Number of trimmed reads&quot;, x_vline = NULL, stacked = TRUE ) 4.0.3.4 Percentage (%) of unique sequences stat_params_unique &lt;- list( x_var = &quot;percent_unique&quot;, x_label = &quot;% of unique sequences&quot;, x_vline = 35, stacked = FALSE ) 4.0.3.5 Percentage (%) of GC content stat_params_gc &lt;- list( x_var = &quot;percent_gc&quot;, x_label = &quot;% of GC content&quot;, x_vline = 60, stacked = FALSE ) 4.0.3.6 Percentage (%) of host reads stat_params_host_reads &lt;- list( x_var = &quot;reads_mapped_host_percent&quot;, x_label = &quot;% of host reads&quot;, x_vline = NULL, stacked = FALSE ) 4.0.3.7 Percentage (%) of human reads stat_params_human_reads &lt;- list( x_var = &quot;reads_mapped_human_percent&quot;, x_label = &quot;% of human reads&quot;, x_vline = 5, stacked = FALSE ) 4.0.3.8 Percentage (%) of bacterial reads NB! In the next iteration, it is better to do this by using the counts dataset instead of the statistics file. stat_params_bacteria_reads &lt;- list( x_var = &quot;reads_mapped_bacteria_percent&quot;, x_label = &quot;% of bacteria reads&quot;, x_vline = 75, stacked = FALSE ) 4.0.3.9 % of unmapped reads stat_params_other_reads &lt;- list( x_var = &quot;reads_mapped_other_percent&quot;, x_label = &quot;% of other reads&quot;, x_vline = 25, stacked = FALSE ) 4.0.3.10 Quality score stat_quality_score &lt;- list( x_var = &quot;quality&quot;, x_label = &quot;Quality score&quot;, x_vline = 5, stacked = FALSE ) 4.0.4 Define a list of all the statistics settings that you want to plot. stat_params_list &lt;- list( stat_total_sequences = stat_params_total_sequences, stat_trimmed_sequences = stat_params_trimmed_sequences, stat_compare_sequences = stat_params_compare_sequences, stat_unique = stat_params_unique, stat_gc = stat_params_gc, stat_host = stat_params_host_reads, stat_human = stat_params_human_reads, stat_bacteria = stat_params_bacteria_reads, stat_other = stat_params_other_reads, stat_quality = stat_quality_score ) save(plot_params_list, stat_params_list, file = &quot;data/params.Rdata&quot; ) "],["lysis-buffer-trial-b11-vs-b12.html", "Chapter 5 Lysis buffer trial (B11 vs B12) 5.1 Load data 5.2 Define plotting settings 5.3 Setup filter conditions 5.4 Plots", " Chapter 5 Lysis buffer trial (B11 vs B12) 5.1 Load data Load the data produced in the previous chapters # load(&quot;data/data.Rdata&quot;) load(&quot;data/plot_data.Rdata&quot;) 5.2 Define plotting settings custom_ggplot_theme &lt;- theme( strip.text.y.left = element_text(angle = 0), strip.text.y.right = element_text(angle = 0), axis.text = element_text(size = 10), axis.title = element_text(size = 12, face = &quot;bold&quot;), strip.background = element_rect(fill = &quot;#dde3e9&quot;, color = &quot;white&quot;, size = 0.8), # Custom facet strip background strip.text = element_text(size = 8, face = &quot;bold&quot;, color = &quot;black&quot;), # Custom facet text strip.placement = &quot;outside&quot;, # Place strip outside the panel grid panel.spacing = unit(0.1, &quot;lines&quot;), # Adjust space between panels panel.grid.major = element_line(color = &quot;#dde3e9&quot;), # Customize major grid lines panel.grid.minor = element_blank(), # Remove minor grid lines panel.background = element_rect(fill = &quot;white&quot;), # Change panel background color plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;) # Adjust plot margins to ensure content fits ) 5.3 Setup filter conditions Use batches MSEB0006 (caecum) and MSEB0010 (colon), from the focal (adult) chicken. For the colon, use the samples that were amplified with 15 PCR cycles instead of 19 (due to the latter’s low quality). plot_params_buffers &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(cycles &lt; 16), quote(batch == &quot;MSEB0006&quot; | batch == &quot;MSEB0010&quot;) ), labels_title = &quot;Lysis Buffer&quot;, facet_formula = &quot;. ~ section + type + buffer&quot;, #&quot;batch + section + type ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;), fill_var = &quot;buffer&quot;, plot_title = &quot;Lysis Buffer trial&quot; ) plot_params &lt;- plot_params_buffers 5.4 Plots 5.4.0.1 Reads that were removed by trimming, mapped to human, chicken, and swine, mapped to bacteria, and unmapped tidy_plot_data_stats_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = counts, fill = label)) + geom_col() + scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Microsample&quot;,y = &quot;Counts&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Number of reads removed by trimming &amp; mapped to human, chicken, swine and bacteria &amp; unmapped&quot;) tidy_plot_data_stats_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = counts, fill = label)) + geom_col(position = &quot;fill&quot;) + scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Microsample&quot;,y = &quot;Counts&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Ratio of reads removed by trimming &amp; mapped to human, chicken, swine and bacteria &amp; unmapped&quot;) 5.4.0.2 Reads that were mapped to human, chicken, swine, and bacteria tidy_plot_data_stats_counts %&gt;% filter(mapping_status %in% c(&#39;bacteria_total_mapped&#39;, &#39;chicken_total_mapped&#39;, &#39;human_total_mapped&#39;, &#39;swine_total_mapped&#39;)) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = counts, fill = label)) + geom_col() + scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Microsample&quot;,y = &quot;Counts&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Number of reads mapped to human, chicken, swine and bacteria&quot;) tidy_plot_data_stats_counts %&gt;% filter(mapping_status %in% c(&#39;bacteria_total_mapped&#39;, &#39;chicken_total_mapped&#39;, &#39;human_total_mapped&#39;, &#39;swine_total_mapped&#39;)) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = counts, fill = label)) + geom_col(position = &quot;fill&quot;) + scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Microsample&quot;,y = &quot;Counts&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Ratio of reads mapped to human, chicken, swine and bacteria&quot;) ### Reads mapped to bacteria plot_data_stats %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = bacteria_total_mapped)) + geom_col(fill = &quot;#B92D65&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Number of reads mapped to bacteria&quot;) plot_data_stats %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = bacteria_percentage)) + geom_col(fill = &quot;#B92D65&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Ratio of reads mapped to bacteria&quot;) tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = count, fill = phylum)) + geom_col(position = &quot;fill&quot;) + scale_fill_manual(values = phylum_colors[-4], drop = FALSE) + labs(x = &quot;Microsample&quot;,y = &quot;Count&quot;, fill = &quot;phylum&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Composition of bacterial phyla in the bacterial reads&quot;) plot_data_stats %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = buffer, y = bacteria_total_mapped)) + geom_boxplot(alpha = 1, fill = &#39;#c1558b&#39;) + facet_nested(. ~ section + type_simple + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + scale_y_continuous(breaks = pretty(plot_data_stats$bacteria_total_mapped, n = 50)) + ggtitle(&quot;Number of bacterial reads&quot;) ### Reads that did not map to any of the used references plot_data_stats %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = unmapped)) + geom_col(fill = &quot;#8d98ae&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Number of unmapped reads&quot;) plot_data_stats %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = unmapped_percentage)) + geom_col(fill = &quot;#8d98ae&quot;) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Ratio of unmapped reads&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = Condition, y = total_sequences, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(breaks = pretty(tidy_plot_data_stats_before_after$total_sequences, n = 30)) + ggtitle(&quot;Number of reads before and after trimming&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = Condition, y = total_sequences, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(breaks = pretty(tidy_plot_data_stats_before_after$total_sequences, n = 80)) + ggtitle(&quot;Number of reads before and after trimming&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = Condition, y = percent_gc, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) + ggtitle(&quot;% GC before and after trimming&quot;) # Combined Histogram &amp; density plot tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = percent_gc, y = ..density.., fill = Condition)) + geom_histogram(binwidth = 0.4, position = &quot;identity&quot;, alpha = 0.5) + geom_density(alpha = 0.6) + facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + geom_vline(xintercept = 50, color = &quot;black&quot;, size = 0.5) + scale_x_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) + ggtitle(&quot;Shift in GC% with trimming - Caecum&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = Condition, y = percent_gc, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(limits = c(10, 90),breaks = seq(10, 90, by = 5)) + ggtitle(&quot;% GC before and after trimming&quot;) # Combined Histogram &amp; density plot tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = percent_gc, y = ..density.., fill = Condition)) + geom_histogram(binwidth = 0.4, position = &quot;identity&quot;, alpha = 0.5) + geom_density(alpha = 0.6) + facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + geom_vline(xintercept = 50, color = &quot;black&quot;, size = 0.5) + scale_x_continuous( limits = c(10, 90), breaks = seq(10, 90, by = 5)) + ggtitle(&quot;Shift in GC% with trimming - Colon&quot;) # Histogram # tidy_plot_data_stats_before_after %&gt;% # filter(!!!plot_params$filter_conditions) %&gt;% # ggplot(aes(x = percent_gc, fill = Condition)) + # geom_histogram(binwidth = 0.5, position = &quot;identity&quot;, alpha = 0.7) + # facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + # xlim(10, 90) + # geom_vline(xintercept = 50)+ # ggtitle(&quot;Shift in GC% with trimming&quot;) # # Density plot # tidy_plot_data_stats_before_after %&gt;% # filter(!!!plot_params$filter_conditions) %&gt;% # ggplot(aes(x = percent_gc, fill = Condition)) + # geom_density(alpha=0.7) + # facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + # xlim(10, 90) + # geom_vline(xintercept = 50)+ # ggtitle(&quot;Shift in GC% with trimming&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = Condition, y = percent_unique, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(limits = c(0, 100),breaks = seq(0, 100, by = 5)) + ggtitle(&quot;% unique seq before and after trimming&quot;) # Combined Histogram &amp; density plot tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = percent_unique, y = ..density.., fill = Condition)) + geom_histogram(binwidth = 0.4, position = &quot;identity&quot;, alpha = 0.5) + geom_density(alpha = 0.6) + facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + geom_vline(xintercept = 50, color = &quot;black&quot;, size = 0.5) + scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 5)) + ggtitle(&quot;Shift in unique seq % with trimming - Caecum&quot;) tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = Condition, y = percent_unique, fill = Condition)) + geom_boxplot(alpha = 1) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(limits = c(0, 100),breaks = seq(0, 100, by = 5)) + ggtitle(&quot;% unique seq before and after trimming&quot;) # Combined Histogram &amp; density plot tidy_plot_data_stats_before_after %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = percent_unique, y = ..density.., fill = Condition)) + geom_histogram(binwidth = 0.4, position = &quot;identity&quot;, alpha = 0.5) + geom_density(alpha = 0.6) + facet_grid(buffer ~ type_simple, scale = &quot;free&quot;) + geom_vline(xintercept = 50, color = &quot;black&quot;, size = 0.5) + scale_x_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 5)) + ggtitle(&quot;Shift in unique seq % with trimming - Colon&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(filter_level == &#39;unfiltered&#39;) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - not filtered&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(filter_level == &#39;filtered_05&#39;) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - genomes filtered at 5% coverage&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Caecum right&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer + filter_level, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - 5 coverage filtering levels&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(filter_level == &#39;unfiltered&#39;) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - not filtered&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(filter_level == &#39;filtered_05&#39;) %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - genomes filtered at 5% coverage&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(section == &#39;Colon&#39;) %&gt;% ggplot(aes(x = buffer, y = value, color = bacteria_percentage)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria percentage&quot;, limits = c(0, 100)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2, alpha = 0.7) + facet_nested(metric ~ section + type_simple + buffer + filter_level, scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + ggtitle(&quot;Alpha diversity - 5 coverage filtering levels&quot;) check also how many of the filtered samples (when we do the filtering) belong to each group # Histogram tidy_plot_alpha_diversity_genomes %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(metric == &#39;richness&#39;) %&gt;% ggplot(aes(x = value, fill = filter_level)) + geom_histogram(binwidth = 4, position = &quot;identity&quot;, alpha = 0.5) + facet_grid(section ~ type_simple + buffer, scales = &quot;fixed&quot;, space = &quot;fixed&quot;) + scale_y_continuous(limits = c(0, 20),breaks = seq(0, 20, by = 1)) + theme_minimal() + custom_ggplot_theme + ggtitle(&quot;Histogram: Samples based on their number of genomes depending on coverage filtering&quot;) # Combined Histogram &amp; density plot tidy_plot_alpha_diversity_genomes %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(metric == &#39;richness&#39;) %&gt;% ggplot(aes(x = value, y = ..density.., fill = filter_level)) + geom_histogram(binwidth = 4, position = &quot;identity&quot;, alpha = 0.5) + geom_density(alpha = 0.6) + facet_grid(section ~ type_simple + buffer, scale = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + ggtitle(&quot;Density &amp; Histogram: Samples based on their number of genomes depending on coverage filtering&quot;) tidy_plot_alpha_diversity_genomes %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(metric == &#39;richness&#39;) %&gt;% filter(value &gt;0) %&gt;% ggplot(aes(x = filter_level, fill = type)) + geom_bar() + facet_grid(section ~ buffer, scale = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + ggtitle(&quot;Number of samples with at least 1 genome present&quot;) tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% ggplot(aes(x = microsample, y = count, fill = phylum)) + geom_col(position = &quot;fill&quot;, colour = &quot;white&quot;, linewidth = 0.1) + scale_fill_manual(values = phylum_colors[-4], drop = FALSE) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Composition of bacterial phyla in the bacterial reads&quot;) # Calculate total abundance for each phylum phylum_order &lt;- tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% group_by(phylum) %&gt;% summarise(total_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(total_abundance) %&gt;% pull(phylum) # Extract the ordered phylum names # Convert &#39;phylum&#39; to a factor with levels ordered by abundance community_composition &lt;- tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% mutate(phylum = factor(phylum, levels = phylum_order)) community_composition %&gt;% ggplot(aes(x = microsample, y = count, fill = phylum)) + geom_col(position = &quot;fill&quot;) + scale_fill_manual(values = phylum_colors[-4], drop = FALSE) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Composition of bacterial phyla in the bacterial reads&quot;) NB! Colours &amp; order not finished!! # tidy_plot_genome_counts %&gt;% # filter(!!!plot_params$filter_conditions) %&gt;% # group_by(microsample, class) %&gt;% # summarise(total_count = sum(count, na.rm = TRUE), # across(where(is.character), ~ first(.)), # .groups = &quot;drop&quot;) %&gt;% # ggplot(aes(x = microsample, y = total_count, fill = class)) + # geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;) + # facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + # theme(axis.text.x = element_text(angle = 90, hjust = 1)) + # custom_ggplot_theme 5.4.1 Genus level plot NB! Colours &amp; order not finished!! NB! This will be changed! generate_shades &lt;- function(base_color, n) { # Generate &#39;n&#39; shades from the base color to a lighter version (not white) colorRampPalette(colors = c(scales::muted(base_color, l = 30), base_color))(n) } Function to generate plots based on taxonomy data and plot parameters. # Calculate total abundance for each phylum phylum_order &lt;- tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% group_by(phylum) %&gt;% summarise(total_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(total_abundance) %&gt;% pull(phylum) # Extract the ordered phylum names # Convert &#39;phylum&#39; to a factor with levels ordered by abundance filtered_data &lt;- tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% group_by(microsample, genus) %&gt;% summarise(total_count = sum(count, na.rm = TRUE), across(where(is.character), ~ first(.)), .groups = &quot;drop&quot;) %&gt;% mutate(phylum = factor(phylum, levels = phylum_order)) # Create an ordered factor for genus within each phylum by abundance filtered_data &lt;- filtered_data %&gt;% group_by(phylum, genus) %&gt;% summarise(genus_abundance = sum(total_count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(phylum, desc(genus_abundance)) %&gt;% mutate(genus_order = factor(genus, levels = unique(genus))) %&gt;% select(phylum, genus, genus_order) %&gt;% right_join(filtered_data, by = c(&quot;phylum&quot;, &quot;genus&quot;)) %&gt;% # Rejoin to original filtered data mutate( genus_for_plot = genus_order, # Use the ordered factor for plotting genus_label = as.character(genus)) %&gt;% # Keep original genus names for labeling select(-genus_order) # Calculate total abundance for each genus across all phyla genus_abundance &lt;- filtered_data %&gt;% group_by(genus) %&gt;% summarise(total_abundance = sum(total_count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(total_abundance)) # Get the top &#39;n&#39; genera by overall abundance top_genera &lt;- genus_abundance %&gt;% slice_head(n = 10) %&gt;% pull(genus) filtered_data &lt;- filtered_data %&gt;% mutate(genus_color = ifelse(genus %in% top_genera, as.character(phylum), &quot;Other&quot;), genus_label = ifelse(genus %in% top_genera, paste(genus, &quot;(&quot;, phylum, &quot;)&quot;), &quot;Other&quot;)) # Reorder &#39;genus_label&#39; factor by genus abundance, using cleaned phylum names for display filtered_data &lt;- filtered_data %&gt;% mutate(genus_label = factor(genus_label,levels = c(paste(sub(&quot;^g__&quot;, &quot;&quot;, top_genera), &quot;(&quot;, sub(&quot;^p__&quot;, &quot;&quot;, filtered_data$phylum[match(top_genera, filtered_data$genus)]), &quot;)&quot;), &quot;Other&quot;) )) # Prepare the phylum colors phylum_colors_named &lt;- phylum_colors#[-4] names(phylum_colors_named) &lt;- levels(filtered_data$phylum) # Generate color mapping for each genus within its phylum color_mapping &lt;- c() for (phylum in unique(filtered_data$phylum)) { phylum_data &lt;- filtered_data %&gt;% filter(phylum == !!phylum &amp; genus_label != &quot;Other&quot;) %&gt;% distinct(genus_label) n_genera &lt;- nrow(phylum_data) phylum_color &lt;- phylum_colors_named[phylum] if (n_genera &gt; 0) { # Generate shades for each genus phylum_shades &lt;- generate_shades(phylum_color, n_genera) names(phylum_shades) &lt;- phylum_data$genus_label color_mapping &lt;- c(color_mapping, phylum_shades) } } # Add grey color for &#39;Other&#39; category color_mapping[&quot;Other&quot;] &lt;- &quot;grey&quot; # Generate the plot ggplot(filtered_data, aes(x = microsample, y = total_count, fill = genus_label, group = interaction(phylum, genus_for_plot))) + geom_bar(stat = &quot;identity&quot;, colour = &quot;white&quot;, linewidth = 0.05) + # Stacked bars with white borders scale_fill_manual(values = color_mapping, drop = FALSE) + # Use manual color scale custom_ggplot_theme + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + custom_ggplot_theme + ggtitle(&quot;Composition of bacterial phyla in the bacterial reads&quot;) # Summarise relabun but keep only the grouping columns filtered_data &lt;- tidy_plot_genome_counts %&gt;% filter(!!!plot_params$filter_conditions) %&gt;% filter(type == &#39;Positive&#39;) %&gt;% group_by(microsample, phylum, genus) %&gt;% summarise(relabun = sum(count), , across(where(is.character), ~ first(.)), .groups = &#39;drop&#39;) summary &lt;- filtered_data %&gt;% group_by(genus) %&gt;% summarise(mean = geometric.mean(relabun, na.rm = T)) %&gt;% #geometric mean because it is a % arrange(-mean) # Reorder taxon_level based on the summary filtered_data %&gt;% mutate(genus = factor(genus, levels = rev(summary %&gt;% pull(genus)))) %&gt;% ggplot(aes(x = relabun, y = genus, group = genus, color = phylum)) + scale_color_manual(values = phylum_colors) + geom_jitter(alpha = 0.3, size=0.5) + facet_nested(. ~ section + type + buffer, scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + theme_minimal() + custom_ggplot_theme + scale_x_continuous(limits = c(0, 1)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

[["index.html", "3D’omics | Avian microbiome - Methods MSSM manuscript Work in progress Chapter 1 Introduction 1.1 Prepare the R environment 1.2 Notes:", " 3D’omics | Avian microbiome - Methods MSSM manuscript Work in progress Antton Alberdi1 Amalia Bogri2 2024-09-18 Chapter 1 Introduction This webbook contains all the code used for the analyses of the MSSM methods manuscript. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/3d-omics/XXX Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(devtools) library(tinytable) library(broom) library(broom.mixed) library(rairtable) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(jpeg) library(patchwork) # For statistics library(spaa) library(vegan) library(Rtsne) library(geiger) library(hilldiv2) library(distillR) library(ANCOMBC) library(lme4) library(Hmsc) library(psych) # For compositional analyses library(zCompositions) library(compositions) # Tidyverse libraries (load dplyr last to avoid conflicts) library(tidyverse) library(dplyr) # Explicitly load dplyr last 1.2 Notes: 1.2.1 Installation of modules Most of the modules can be downloaded from CRAN with ‘install.packages(’XXX’, dependencies = TRUE)‘. Four modules are from Bioconductor. Install with: ’install.packages(’BiocManager’, dependencies = TRUE) BiocManager::install(c(“phyloseq”, “ggtreeExtra”,“ggtree”,“ANCOMBC”))’ Two modules are from Antton’s github. Install with: ‘install.packages(’remotes’, dependencies = TRUE) remotes::install_github(‘anttonalberdi/hilldiv2’) remotes::install_github(‘anttonalberdi/distillR’)’ 1.2.2 Airtable access: Currently the metadata is loaded from the 3D’omics airtable. In order to access it you need your own API key (from Antton). set_airtable_api_key(‘XXXXX’, install = TRUE) University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ University of Copenhagen, amalia.bogri@sund.ku.dk↩︎ "],["data-preparation.html", "Chapter 2 Data preparation 2.1 Sample metadata 2.2 Count data 2.3 Filter and normalise data 2.4 Color scheme 2.5 Wrap working objects", " Chapter 2 Data preparation 2.1 Sample metadata Import sample metadata from the airtable. sample_metadata &lt;- airtable(&quot;4-MSE-Info&quot;, &quot;appKakM1bnKSekwuW&quot;) %&gt;% # get base ID from Airtable browser URL read_airtable(., fields = c(&quot;ID&quot;, &quot;LabBatch_text&quot;, &quot;IntestinalSection&quot;, &quot;SampleType&quot;, &quot;Xcoord&quot;, &quot;Ycoord&quot;, &quot;SizeApprox&quot;, &quot;cryosection_text&quot;, &quot;buffer_text&quot;, &quot;Collection_Success&quot;, &quot;Collection_attempts&quot;, &quot;UsedCycles&quot;, &quot;animal_temp&quot;, &quot;Protocol_text&quot;), id_to_col = TRUE) %&gt;% filter(LabBatch_text %in% c(&quot;MSEB0006&quot;, &quot;MSEB0009&quot;, &quot;MSEB0010&quot;, &quot;MSEB0011&quot;, &quot;MSEB0012&quot;, &quot;MSEB0014&quot;, &quot;MSEB0015&quot;)) %&gt;% rename(batch = LabBatch_text, microsample = ID, section = IntestinalSection, type = SampleType, cryosection = cryosection_text, buffer = buffer_text, collection = Collection_Success, collection_attempts = Collection_attempts, cycles = UsedCycles, animal = animal_temp, size = SizeApprox, protocol = Protocol_text) %&gt;% select(microsample, section, type, batch, cryosection, buffer, Xcoord, Ycoord, size, collection, collection_attempts, cycles, animal, protocol) %&gt;% unnest(c(section, Xcoord, Ycoord, size, collection, cycles)) %&gt;% arrange(microsample) print(names(sample_metadata)) 2.2 Count data read_counts &lt;- read_tsv(&quot;data/MSEB0006_read_counts.tsv&quot;, show_col_types = FALSE) %&gt;% left_join(read_tsv(&quot;data/MSEB0009_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0010_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0011_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0012_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0014_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0015_read_counts.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) 2.2.1 Base hit table This is the document containing the number of nucleotide bases have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. basehits &lt;- read_tsv(&quot;data/MSEB0006_covered_bases.tsv&quot;, show_col_types = FALSE) %&gt;% left_join(read_tsv(&quot;data/MSEB0009_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0010_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0011_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0012_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0014_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% left_join(read_tsv(&quot;data/MSEB0015_covered_bases.tsv&quot;, show_col_types = FALSE), by = &quot;sequence_id&quot;) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) 2.2.2 Genome metadata Relevant metadata of genomes is fetched from 2-3 files and merged into one genome metadata object for downstream analyses. 2.2.2.1 Taxonomy This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses. genome_taxonomy &lt;- read_tsv(&quot;data/genome_taxonomy.tsv&quot;, show_col_types = FALSE) %&gt;% rename(genome = user_genome) %&gt;% mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% separate(classification, c(&quot;domain&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;), sep = &quot;;&quot;) %&gt;% select(genome, domain, phylum, class, order, family, genus, species) %&gt;% arrange(match(genome, read_counts$genome)) 2.2.2.2 Genome quality Quality properties of the genomes. genome_quality &lt;- read_tsv(&quot;data/genome_quality.tsv&quot;, show_col_types = FALSE) %&gt;% rename(genome = 1) %&gt;% mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% arrange(match(genome, read_counts$genome)) %&gt;% select(genome, Completeness, Contamination, Coding_Density, Genome_Size) %&gt;% rename(completeness = Completeness, contamination = Contamination, coding_density = Coding_Density, length = Genome_Size) 2.2.2.3 Merged metadata object Merge taxonomy, length and quality information genome_metadata &lt;- genome_taxonomy %&gt;% left_join(genome_quality, by = join_by(genome == genome)) # join quality 2.2.3 Genome tree This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes. genome_tree &lt;- read.tree(&quot;data/genome_tree.tre&quot;) genome_tree$tip.label &lt;- str_replace_all(genome_tree$tip.label, &quot;&#39;&quot;, &quot;&quot;) # remove single quotes in MAG names genome_tree &lt;- keep.tip(genome_tree, tip = read_counts$genome) # keep only MAG tips 2.2.4 MAG functional annotations This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR. genome_annotations &lt;- read_tsv(&quot;data/genome_annotations.tsv.xz&quot;, show_col_types = FALSE) %&gt;% rename(gene = 1, genome = 2) 2.3 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. 2.3.1 Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. genome_coverage &lt;- basehits %&gt;% mutate(across(where(is.numeric), ~ . / genome_metadata$length)) 2.3.2 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. min_coverage &lt;- 0.3 read_counts_filt &lt;- genome_coverage %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% mutate(across(-1, ~ . * read_counts[[cur_column()]])) 2.3.3 Generate genome count table After filtering the low-coverage reads, read counts are transformed into genome counts using genome-length and read-length information. readlength &lt;- 150 # change if sequencing read length is different genome_counts_filt &lt;- read_counts_filt %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) genome_counts &lt;- read_counts %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) 2.3.4 Distil functional annotations Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses. genome_gifts &lt;- distill(genome_annotations, GIFT_db, genomecol = 2, annotcol = c(9, 10, 19)) 2.4 Color scheme AlberdiLab projects use unified color schemes developed for the Earth Hologenome Initiative, to facilitate figure interpretation. phylum_colors &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;, show_col_types = FALSE) %&gt;% right_join(genome_metadata, by = join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% pull(colors, name = phylum) 2.5 Wrap working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. save(read_counts, read_counts_filt, genome_counts, genome_counts_filt, genome_tree, genome_metadata, genome_gifts, sample_metadata, phylum_colors, file = &quot;data/data.Rdata&quot; ) read_counts: Number of reads mapped to each genome in each sample. Note this is the unfiltered and unnormalised raw community composition table. genome_counts: Number of genomes quantified in each sample, calculated through filtering and normalising read_counts. This is the community composition table to be used in downstream analyses unless otherwise stated. genome_tree: Phylogenetic tree of the genomes, to be employed in downstream phylogenetic analyses. genome_metadata: Taxonomic and quality information of the genomes. sample_metadata: Treatment/population and other relevant metadata of the samples. "],["data-quality.html", "Chapter 3 Data quality 3.1 Load the data that were prepared in the previous chapter. 3.2 Data loading 3.3 Data plotting 3.4 Plot figures for all the statistics and all experiments.", " Chapter 3 Data quality 3.1 Load the data that were prepared in the previous chapter. load(&quot;data/data.Rdata&quot;) 3.2 Data loading 3.2.1 Define lists with the names of the files required for the statistics. The files were produced by the bioinformatics pipeline, and located in 3D’omics ERDA. 3.2.1.1 General sequencing statistics of sequencing. Used the multiqc_fastqc.txt because the multiqc_general_stats.txt did not exist in all batches. multiqc_fastqc_list &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/reads_data/multiqc_fastqc.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/reads_data/multiqc_fastqc.txt&quot; # MSEB0015 ) 3.2.1.2 General sequencing statistics of sequencing after trimming. multiqc_fastqc_trimmed_list &lt;- list( list(file = &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0006 list(file = &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0009 list(file = &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0010 list(file = &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0011 list(file = &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0012 list(file = &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_fastqc.txt&quot;, column_name = &quot;Total Sequences&quot;), # MSEB0015 list(file = &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/samtools-flagstat-dp_Read_counts.txt&quot;, column_name = &quot;Total Reads&quot;) # MSEB0014 ) 3.2.1.3 Percentage (%) of host and and of human mapped reads. NB! This % is calculated on the trimmed reads. NB! The reads are mapped to 3 databases (human, chicken, pig) sequentially, so the % is after removing reads mapped to the previous db. host_human_mapping_files &lt;- list( list(file = &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0006 list(file = &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0009 list(file = &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0010 list(file = &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0011 list(file = &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0012 list(file = &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/preprocess_data/multiqc_samtools_flagstat.txt&quot;, column_name = &quot;mapped_passed_pct&quot;), # MSEB0015 list(file = &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/preprocess_data/samtools-flagstat-dp_Percentage_of_total.txt&quot;, column_name = &quot;Properly Paired&quot;) # MSEB0014 ) 3.2.1.4 Number and percentage (%) of bacteria mapped reads. NB! This % is calculated on the trimmed reads after filtering for human, chicken, and pig reads. ‘Non mapped reads’ at this point are trimmed but not mapped to human, chicken, pig, or bacterial MAG catalogue. bacteria_mapping_files &lt;- c( &quot;https://sid.erda.dk/share_redirect/G2guEHWh9v/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0006 &quot;https://sid.erda.dk/share_redirect/HiPNk7p4MG/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0009 &quot;https://sid.erda.dk/share_redirect/cdU6P6sNuj/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0010 &quot;https://sid.erda.dk/share_redirect/EUKYidpvOO/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0011 &quot;https://sid.erda.dk/share_redirect/dEy2D1OmZi/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0012 &quot;https://sid.erda.dk/share_redirect/B0E8AbA7Eu/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot;, # MSEB0014 &quot;https://sid.erda.dk/share_redirect/hT3CftfSyw/reports/by_step/quantify_data/multiqc_samtools_stats.txt&quot; # MSEB0015 ) 3.2.2 Define functions to load the statistics. At this step we choose the relevant rows and columns from the bioinformatics output. 3.2.2.1 General sequencing statistics of sequencing. multiqc_fastqc_read_and_select &lt;- function(file) { read_tsv(file, col_types = cols_only( &quot;Sample&quot; = col_character(), &quot;Total Sequences&quot; = col_double(), &quot;%GC&quot; = col_double(), &quot;total_deduplicated_percentage&quot; = col_double() ), show_col_types = FALSE ) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename( microsample = Sample, total_sequences = `Total Sequences`, percent_gc = `%GC`, percent_unique = total_deduplicated_percentage ) %&gt;% select(microsample, total_sequences, percent_gc, percent_unique) } 3.2.2.2 General sequencing statistics of sequencing after trimming. trimmed_multiqc_fastqc_read_and_select &lt;- function(file_info) { file &lt;- file_info$file # Extract the file path column_name &lt;- file_info$column_name # Extract the column name read_tsv(file, show_col_types = FALSE ) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% rename( microsample = Sample, total_trimmed_sequences = !!sym(column_name) ) %&gt;% select(microsample, total_trimmed_sequences) } 3.2.2.3 Percentage (%) of host and and of human mapped reads. host_human_mapping_process_file &lt;- function(file, column_name) { read_tsv(file, show_col_types = FALSE) %&gt;% mutate(reference = case_when( grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, TRUE ~ NA_character_ )) %&gt;% filter(!is.na(reference)) %&gt;% # Remove rows where reference is NA mutate( microsample = str_extract(Sample, &quot;M\\\\d+&quot;), reads_mapped_host_percent = ifelse(reference == &quot;chicken&quot;, !!sym(column_name), NA_real_), reads_mapped_human_percent = ifelse(reference == &quot;human&quot;, !!sym(column_name), NA_real_) ) %&gt;% select(microsample, reads_mapped_host_percent, reads_mapped_human_percent) } 3.2.2.4 Number and percentage (%) of bacteria mapped reads. bacteria_mapping_process_file &lt;- function(file) { read_tsv(file, show_col_types = FALSE) %&gt;% filter(str_detect(Sample, &quot;mgg-pbdrep&quot;)) %&gt;% #select samples mapped to mgg-pdrep database (i.e. NO &#39;salmonella&#39; or &#39;chicken big mag&#39;) mutate( microsample = str_extract(Sample, &quot;M\\\\d+&quot;), reads_mapped_bacteria = reads_mapped, reads_mapped_bacteria_percent = reads_mapped_percent ) %&gt;% select(microsample, reads_mapped_bacteria, reads_mapped_bacteria_percent) } 3.2.3 Load the statistics. Load each file with the functions above (to select the relevant columns/rows). Group by ‘microsample’ &amp; estimate sums/means/etc. because in some files each microsample is split into two rows. Estimate the quality score of each sample, and add as a new column. This is optional and might be removed. Add an ‘others’, i.e. not mapped reads as a new column. Select which columns to include in the final object. final_combined_stats &lt;- bind_rows( lapply(multiqc_fastqc_list, multiqc_fastqc_read_and_select),# Process FastQC stats files lapply(multiqc_fastqc_trimmed_list, trimmed_multiqc_fastqc_read_and_select),# Process FastQC stats files after trimming lapply(host_human_mapping_files, function(x) { # Process host and human mapping files host_human_mapping_process_file(x$file, x$column_name) }), lapply(bacteria_mapping_files, bacteria_mapping_process_file) # Process bacterial mapping files ) %&gt;% group_by(microsample) %&gt;% # because there are two rows per sample in the multi_fastqc files. summarise( total_sequences = sum(total_sequences, na.rm = TRUE), # sum the no. of sequences in the two rows of each sample total_trimmed_sequences = sum(total_trimmed_sequences, na.rm = TRUE), percent_gc = mean(percent_gc, na.rm = TRUE), # mean of GC% for the two rows. Only works because the no.of sequences is the same in the two rows. percent_unique = mean(percent_unique, na.rm = TRUE), # mean of unique% for the two rows. Only works because the no.of sequences is the same in the two rows. reads_mapped_host_percent = mean(reads_mapped_host_percent, na.rm = TRUE), # only one value here, so not actual mean reads_mapped_human_percent = mean(reads_mapped_human_percent, na.rm = TRUE), # only one value here, so not actual mean reads_mapped_bacteria = sum(reads_mapped_bacteria, na.rm = TRUE), # only one value here, so not actual sum reads_mapped_bacteria_percent = mean(reads_mapped_bacteria_percent, na.rm = TRUE) # only one value here, so not actual sum ) %&gt;% # estimate quality score of each sample mutate( depth = ifelse(total_sequences &gt; 10000000, 1, 0), duplicates = ifelse(percent_unique &gt; 35, 1, 0), gc = ifelse(percent_gc &lt; 60, 1, 0), human = ifelse(reads_mapped_human_percent &lt; 5, 1, 0), bacteria = ifelse(reads_mapped_bacteria_percent &gt; 75, 1, 0), quality = depth + duplicates + gc + human + bacteria, reads_mapped_other_percent = 100 - (reads_mapped_bacteria_percent) # calculate &#39;other&#39; reads percentage - the bacterial % is from the trimmed &amp; filtered reads already ) %&gt;% select(microsample, total_sequences, total_trimmed_sequences, percent_gc, percent_unique, reads_mapped_host_percent, reads_mapped_human_percent, reads_mapped_bacteria, reads_mapped_bacteria_percent, reads_mapped_other_percent, quality) 3.2.4 Write the final stats dataframe to a TSV file final_combined_stats %&gt;% write_tsv(&quot;results/final_combined_stats.tsv&quot;) #print(final_combined_stats) 3.3 Data plotting 3.3.1 Define lists that contain the settings for plotting each statistic. 3.3.1.1 Sequencing depth This is the total number of sequenced reads. stat_params_total_sequences &lt;- list( x_var = &quot;total_sequences&quot;, x_label = &quot;Number of reads&quot;, x_vline = 10000000, stacked = FALSE ) 3.3.1.2 Number of sequences after trimming This is the total number of sequenced reads after trimming the adaptors and low quality sequences. stat_params_trimmed_sequences &lt;- list( x_var = &quot;total_trimmed_sequences&quot;, x_label = &quot;Number of trimmed reads&quot;, x_vline = NULL, stacked = FALSE ) 3.3.1.3 Number of trimmed sequences This is the difference between total reads and reads after trimming. prepare_stacked_data &lt;- function(data) { data %&gt;% mutate(trimmed_reads = total_sequences - total_trimmed_sequences) %&gt;% pivot_longer(cols = c(total_trimmed_sequences, trimmed_reads), names_to = &quot;read_type&quot;, values_to = &quot;reads&quot;) %&gt;% mutate(read_type = factor(read_type, levels = c(&quot;trimmed_reads&quot;, &quot;total_trimmed_sequences&quot;))) } stat_params_compare_sequences &lt;- list( x_var = &quot;total_trimmed_sequences&quot;, x_label = &quot;Number of trimmed reads&quot;, x_vline = NULL, stacked = TRUE ) 3.3.1.4 Percentage (%) of unique sequences stat_params_unique &lt;- list( x_var = &quot;percent_unique&quot;, x_label = &quot;% of unique sequences&quot;, x_vline = 35, stacked = FALSE ) 3.3.1.5 Percentage (%) of GC content stat_params_gc &lt;- list( x_var = &quot;percent_gc&quot;, x_label = &quot;% of GC content&quot;, x_vline = 60, stacked = FALSE ) 3.3.1.6 Percentage (%) of host reads stat_params_host_reads &lt;- list( x_var = &quot;reads_mapped_host_percent&quot;, x_label = &quot;% of host reads&quot;, x_vline = NULL, stacked = FALSE ) 3.3.1.7 Percentage (%) of human reads stat_params_human_reads &lt;- list( x_var = &quot;reads_mapped_human_percent&quot;, x_label = &quot;% of human reads&quot;, x_vline = 5, stacked = FALSE ) 3.3.1.8 Percentage (%) of bacterial reads NB! In the next iteration, it is better to do this by using the counts dataset instead of the statistics file. stat_params_bacteria_reads &lt;- list( x_var = &quot;reads_mapped_bacteria_percent&quot;, x_label = &quot;% of bacteria reads&quot;, x_vline = 75, stacked = FALSE ) 3.3.1.9 % of unmapped reads stat_params_other_reads &lt;- list( x_var = &quot;reads_mapped_other_percent&quot;, x_label = &quot;% of other reads&quot;, x_vline = 25, stacked = FALSE ) 3.3.1.10 Quality score stat_quality_score &lt;- list( x_var = &quot;quality&quot;, x_label = &quot;Quality score&quot;, x_vline = 5, stacked = FALSE ) 3.3.2 Define a list of all the statistics settings that you want to plot. stat_params_list &lt;- list( stat_total_sequences = stat_params_total_sequences, stat_trimmed_sequences = stat_params_trimmed_sequences, stat_compare_sequences = stat_params_compare_sequences, stat_unique = stat_params_unique, stat_gc = stat_params_gc, stat_host = stat_params_host_reads, stat_human = stat_params_human_reads, stat_bacteria = stat_params_bacteria_reads, stat_other = stat_params_other_reads, stat_quality = stat_quality_score ) 3.3.3 Define lists that contain the plot settings for different experiments/trials 3.3.3.1 B11 vs B12 lysis buffers Compare buffer B11 and B12. Use batches MSEB0006 (caecum) and MSEB0010 (colon), from the focal (adult) chicken. For the colon, use the samples that took 15 PCR cycles instead of 19 (due to the latter’s low quality). plot_params_buffers &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(cycles &lt; 16), quote(batch == &quot;MSEB0006&quot; | batch == &quot;MSEB0010&quot;) ), labels_title = &quot;Lysis Buffer&quot;, facet_formula = &quot;section + type + buffer ~ .&quot;, #&quot;batch + section + type ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;), # &#39;#a3d1cf&#39;,&#39;#d1a3cf&#39; fill_var = &quot;buffer&quot;, plot_title = &quot;Lysis Buffer trial&quot; ) 3.3.3.2 15 vs 19 PCR cycles Use the colon samples (MSEB0010). Maybe separate by buffer?? plot_params_cycles &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0010&quot;) ), labels_title = &quot;PCR cycles&quot;, facet_formula = &quot;section + type + cycles ~ .&quot;, # &quot;batch + section + type ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#e56969&#39;), fill_var = &quot;factor(cycles)&quot;, plot_title = &quot;PCR cycles trial&quot; ) 3.3.3.3 Limit of detection trial: Different LMD sizes Use batch MSEB0014 (caecum). plot_params_LOD &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0014&quot;) ), labels_title = &quot;LMD size&quot;, facet_formula = &quot;type + size ~ .&quot;, #&quot;batch + section + type + cryosection ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))&quot;, plot_title = &quot;Limit of detection (LMD size)&quot; ) 3.3.3.4 Automation trial Compare the quality of library prep with DreamPrep (MSEB0015) vs manual (MSEB0011) for ceacum of focal chicken plot_params_automation &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0015&quot;), quote(animal == &#39;G121e&#39;) ), labels_title = &quot;Automation&quot;, facet_formula = &quot;batch + type + cryosection ~ .&quot;, #&quot;batch + section + type + cryosection ~ .&quot; scale_fill_manual_val = c(&#39;#e56969&#39;,&#39;#c1558b&#39;), fill_var = &quot;batch&quot;, plot_title = &quot;Automation test&quot; ) 3.3.3.5 Full vs. half reaction (library prep with UltraLowV2 Tecan kit) Compare the quality of library prep with full reaction (MSEB0006, MSEB0009, MSEB0010) vs half reaction (MSEB0011, MSEB0012) of focal chicken, ceacum and colon (only low PCR cycles). NB! both buffers. plot_params_protocol &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;&amp; batch != &quot;MSEB0015&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16) ), labels_title = &quot;Protocol&quot;, facet_formula = &quot;type + section + protocol ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#c1558b&#39;,&#39;#8a49a1&#39;), fill_var = &quot;protocol&quot;, plot_title = &quot;Full vs. half reactions&quot; ) 3.3.3.6 Ceacum vs colon Compare the quality of colon vs caecum samples of the focal chicken (and only low PCR cycles) plot_params_section &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch == &quot;MSEB0009&quot;|batch == &quot;MSEB0010&quot;|batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16) ), labels_title = &quot;Section&quot;, facet_formula = &quot;type + section ~ .&quot;, #&quot;type+ batch ~ .&quot; scale_fill_manual_val = c(&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;section&quot;, plot_title = &quot;Caecum vs colon&quot; ) 3.3.3.7 Adult vs young chicken Compare the quality of samples from the focal (adult) chicken vs the younger chicken, for both colon (MSEB0012) and caecum (MSEB0011). plot_params_animal &lt;- list( filter_conditions = list( quote(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) ), labels_title = &quot;Animal&quot;, facet_formula = &quot;type + section + animal ~ .&quot;, #&quot;type+ batch + section + animal ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#c1558b&#39;), fill_var = &quot;animal&quot;, plot_title = &quot;Adult vs young chicken&quot; ) 3.3.3.8 LMD collection attemps Compare the quality of samples coloured by the number of attempts to collect the LMD sample. LOD trial excluded. plot_params_collection_attempts &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16), quote(collection_attempts&gt;0) ), labels_title = &quot;Collection attempts&quot;, facet_formula = &quot;type + section + collection_attempts ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;factor(collection_attempts)&quot;, plot_title = &quot;LMD collection attempts&quot; ) 3.3.3.9 LMD collection success Compare the quality of samples coloured by the LMD success jugded upon visual inspection of the collection lids. LOD trial excluded. plot_params_collection_success &lt;- list( filter_conditions = list( quote(section != &quot;Ileum&quot;), quote(batch != &quot;MSEB0014&quot;), quote(animal == &#39;G121e&#39;), quote(cycles&lt;16), quote(collection_attempts&gt;0) ), labels_title = &quot;Collection_success&quot;, facet_formula = &quot;type + section + collection ~ .&quot;, #&quot;type + section + batch ~ .&quot; scale_fill_manual_val = c(&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;), fill_var = &quot;collection&quot;, plot_title = &quot;LMD collection success&quot; ) 3.3.4 Define a list of all the experiments/trials settings that you want to plot. plot_params_list &lt;- list( plot_buffers = plot_params_buffers, plot_cycles = plot_params_cycles, plot_LOD = plot_params_LOD, plot_automation = plot_params_automation, plot_protocol = plot_params_protocol, plot_section = plot_params_section, plot_animal = plot_params_animal, plot_collection_attempts = plot_params_collection_attempts, plot_collection_success = plot_params_collection_success ) 3.3.5 Define barplot function First, define the plotting settings. # Define a custom theme for your taxonomy plots custom_ggplot_theme &lt;- theme( strip.text.y.left = element_text(angle = 0), strip.text.y.right = element_text(angle = 0), axis.text = element_text(size = 6), axis.title = element_text(size = 12, face = &quot;bold&quot;), strip.background = element_rect(fill = &quot;#dde3e9&quot;, color = &quot;white&quot;, size = 0.8), # Custom facet strip background strip.text = element_text(size = 8, face = &quot;bold&quot;, color = &quot;black&quot;), # Custom facet text strip.placement = &quot;outside&quot;, # Place strip outside the panel grid panel.spacing = unit(0.1, &quot;lines&quot;), # Adjust space between panels panel.grid.major = element_line(color = &quot;#dde3e9&quot;), # Customize major grid lines panel.grid.minor = element_blank(), # Remove minor grid lines panel.background = element_rect(fill = &quot;white&quot;), # Change panel background color plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;) # Adjust plot margins to ensure content fits ) This function can be used for plotting different statistics (see stat_params list) and different experiments (see plot_params list). plot_data &lt;- function(data, metadata, plot_params, stat_params, bar_width = 0.9) { # Merge the data with metadata plot_data &lt;- data %&gt;% left_join(metadata, by = join_by(microsample == microsample)) # Apply filters if provided if (length(plot_params$filter_conditions) &gt; 0) { plot_data &lt;- plot_data %&gt;% filter(!!!plot_params$filter_conditions) } # Preprocess data if stacked plot is needed if (stat_params$stacked) { plot_data &lt;- prepare_stacked_data(plot_data) } # Conditionally apply factor() for size based on the presence of &#39;size&#39; in plot_params$fill_var if (grepl(&quot;size&quot;, plot_params$fill_var)) { plot_data &lt;- plot_data %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) } # Calculate plot height dynamically based on number of microsamples plot_height &lt;- 5 + (nrow(plot_data) * 0.2) #10 + (nrow(plot_data) * 0.01) # Create the ggplot object p &lt;- ggplot(plot_data) + { if (stat_params$stacked) { # Plot stacked bars if stacked is TRUE with fixed bar width geom_col(aes(x = reads, y = microsample, fill = read_type), position = &quot;stack&quot;, width = bar_width) } else { # Plot normal bars if stacked is FALSE with fixed bar width geom_col(aes_string(x = stat_params$x_var, y = &quot;microsample&quot;, fill = plot_params$fill_var, width = bar_width)) }} + scale_fill_manual(values = if (stat_params$stacked) { # Use different shades for stacked bars c(&quot;total_trimmed_sequences&quot; = plot_params$scale_fill_manual_val[1], &quot;trimmed_reads&quot; = scales::muted(plot_params$scale_fill_manual_val[1])) } else { # Use specified colors for non-stacked plots plot_params$scale_fill_manual_val }) + facet_nested(as.formula(plot_params$facet_formula), scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + labs(x = stat_params$x_label, y = &quot;Microsamples&quot;, fill = plot_params$labels_title, title = plot_params$plot_title ) + coord_cartesian(clip = &quot;off&quot;) # Add geom_vline if x_vline is provided if (!is.null(stat_params$x_vline)) { p &lt;- p + geom_vline(xintercept = stat_params$x_vline, linetype = &quot;dashed&quot;, color = &quot;#1f2455&quot;, size = 0.3) } # Return plot and calculated height return(list(plot = p, height = plot_height)) } 3.4 Plot figures for all the statistics and all experiments. NB! This function also saves the plots in a file. Comment out if you don’t want that. # Initialize a list to store plots #fig.height=10, fig.fullwidth=TRUE, fig.height=(5 + (nrow(plot_data) * 0.2)/ 2.54 plots_list &lt;- list() # Loop through each combination of plot_params and stat_params for (plot_param_name in names(plot_params_list)) { plot_params &lt;- plot_params_list[[plot_param_name]] for (stat_param_name in names(stat_params_list)) { stat_params &lt;- stat_params_list[[stat_param_name]] # Generate the plot with dynamic height result &lt;- plot_data(final_combined_stats, sample_metadata, plot_params, stat_params) plot &lt;- result$plot plot_height &lt;- result$height # Create a dynamic plot name plot_name &lt;- paste0(plot_param_name, &quot;_&quot;, stat_param_name) # Store the plot in the list plots_list[[plot_name]] &lt;- plot # Print the plot print(plot) # Save the plot to a file with dynamic height ggsave(filename = paste0(&quot;results/figures/statistics/&quot;, plot_name, &quot;.jpg&quot;), plot = plot, device = &quot;jpg&quot;, width = 30, height = plot_height, units = &quot;cm&quot;, dpi = 300, limitsize = FALSE) } } "],["community-composition.html", "Chapter 4 Community composition 4.1 Load data 4.2 Community composition barplots 4.3 Phylogeny &amp; MAG heatmap visualisation 4.4 Composition jitterplot functions 4.5 Covariance", " Chapter 4 Community composition 4.1 Load data Load the data produced in the previous chapter load(&quot;data/data.Rdata&quot;) quality &lt;- read_tsv(&quot;results/final_combined_stats.tsv&quot;, col_types = cols_only(microsample = col_character(), quality = col_double()), show_col_types = FALSE ) Prepare the dataset by joining the sample metadata, genome metadata, quality data to the counts data. prepare_taxonomy_dataset &lt;- function(genome_counts_df, genome_metadata, sample_metadata, quality) { taxonomy_dataset &lt;- genome_counts_df %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% # Apply TSS normalization (i.e., scale each sample to 1) pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% # Reduce to minimum number of columns left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% # Append genome metadata left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% # Append sample metadata left_join(quality, by = join_by(microsample == microsample)) %&gt;% # Append quality data mutate(section = unlist(section)) %&gt;% # Flatten section if it&#39;s a list filter(!is.na(count)) %&gt;% # Filter out rows with NA in count filter(count &gt; 0) # Filter out rows with count &lt;= 0 return(taxonomy_dataset) } 4.2 Community composition barplots Function to generate plots based on taxonomy data and plot parameters. You can also input whether you want to filter based on the quality of the microsample or its type. E.g. filter_quality = 5, filter_type = c(“Positive”) or filter_type = c(“NegativeMembrane”, “NegativeCollection”, “NegativeReaction”). 4.2.1 Phylum level plot plot_taxonomy_data &lt;- function(taxonomy_data, plot_params, filter_quality = NULL, filter_type = NULL) { # Apply filters based on plot_params filtered_data &lt;- taxonomy_data # Dynamically apply filter conditions if (length(plot_params$filter_conditions) &gt; 0) { filtered_data &lt;- filtered_data %&gt;% filter(!!!plot_params$filter_conditions) } # Dynamically apply the quality filter if provided if (!is.null(filter_quality)) { filtered_data &lt;- filtered_data %&gt;% filter(quality == filter_quality) } # Dynamically apply the type filter (positive/negative) if provided if (!is.null(filter_type)) { filtered_data &lt;- filtered_data %&gt;% filter(type %in% filter_type) } # Conditionally apply factor() for size based on the presence of &#39;size&#39; in plot_params$fill_var if (grepl(&quot;size&quot;, plot_params$fill_var)) { filtered_data &lt;- filtered_data %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) } # Calculate total abundance for each phylum phylum_order &lt;- filtered_data %&gt;% group_by(phylum) %&gt;% summarise(total_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(total_abundance)) %&gt;% pull(phylum) # Extract the ordered phylum names # Convert &#39;phylum&#39; to a factor with levels ordered by abundance filtered_data &lt;- filtered_data %&gt;% mutate(phylum = factor(phylum, levels = phylum_order)) # Create an ordered factor for genus within each phylum by abundance filtered_data &lt;- filtered_data %&gt;% group_by(phylum, genus) %&gt;% summarise(genus_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(phylum, desc(genus_abundance)) %&gt;% mutate(genus_order = factor(genus, levels = unique(genus))) %&gt;% select(phylum, genus, genus_order) %&gt;% right_join(filtered_data, by = c(&quot;phylum&quot;, &quot;genus&quot;)) %&gt;% # Rejoin to original filtered data mutate(genus = genus_order) %&gt;% # Apply ordered factor to genus select(-genus_order) # Calculate plot height dynamically based on number of microsamples included in this plot # Group by microsample and count the occurrences num_microsamples &lt;- filtered_data %&gt;% count(microsample) # print(nrow(num_microsamples)) plot_height &lt;- 5 + (nrow(num_microsamples) * 0.2) #10 + (nrow(plot_data) * 0.01) # Generate the plot p &lt;- ggplot(filtered_data, aes(x = count, y = microsample, fill = phylum, group = interaction(phylum, genus))) + # Group by multiple taxonomic levels geom_bar(stat = &quot;identity&quot;, colour = &quot;white&quot;, linewidth = 0.1) + # Stacked bars with white borders scale_fill_manual(values = phylum_colors[-4], drop = FALSE) + # Use manual color scale and ensure all phyla are represented labs( x = &quot;Relative abundance&quot;, y = &quot;Microsamples&quot;, fill = &quot;Phylum&quot;, title = plot_params$plot_title ) + facet_nested(as.formula(plot_params$facet_formula), scales = &quot;free&quot;, space = &quot;free&quot;) + # Dynamic faceting guides(fill = guide_legend(ncol = 1)) + custom_ggplot_theme return(list(plot = p, height = plot_height)) } 4.2.2 Genus level plot Function to generate shades for each genus within the same phylum generate_shades &lt;- function(base_color, n) { # Generate &#39;n&#39; shades from the base color to a lighter version (not white) colorRampPalette(colors = c(scales::muted(base_color, l = 30), base_color))(n) } Function to generate plots based on taxonomy data and plot parameters. genus_plot_taxonomy_data &lt;- function(taxonomy_data, plot_params, filter_quality = NULL, filter_type = NULL, top_n = 20) { # Apply filters based on plot_params filtered_data &lt;- taxonomy_data # Dynamically apply filter conditions if (length(plot_params$filter_conditions) &gt; 0) { filtered_data &lt;- filtered_data %&gt;% filter(!!!plot_params$filter_conditions) } # Dynamically apply the quality filter if provided if (!is.null(filter_quality)) { filtered_data &lt;- filtered_data %&gt;% filter(quality == filter_quality) } # Dynamically apply the type filter (positive/negative) if provided if (!is.null(filter_type)) { filtered_data &lt;- filtered_data %&gt;% filter(type %in% filter_type) } # Conditionally apply factor() for size based on the presence of &#39;size&#39; in plot_params$fill_var if (grepl(&quot;size&quot;, plot_params$fill_var)) { filtered_data &lt;- filtered_data %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) } # Calculate total abundance for each phylum phylum_order &lt;- filtered_data %&gt;% group_by(phylum) %&gt;% summarise(total_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(total_abundance)) %&gt;% pull(phylum) # Extract the ordered phylum names # Convert &#39;phylum&#39; to a factor with levels ordered by abundance filtered_data &lt;- filtered_data %&gt;% mutate(phylum = factor(phylum, levels = phylum_order)) # Create an ordered factor for genus within each phylum by abundance filtered_data &lt;- filtered_data %&gt;% group_by(phylum, genus) %&gt;% summarise(genus_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(phylum, desc(genus_abundance)) %&gt;% mutate(genus_order = factor(genus, levels = unique(genus))) %&gt;% select(phylum, genus, genus_order) %&gt;% right_join(filtered_data, by = c(&quot;phylum&quot;, &quot;genus&quot;)) %&gt;% # Rejoin to original filtered data mutate( genus_for_plot = genus_order, # Use the ordered factor for plotting genus_label = as.character(genus) ) %&gt;% # Keep original genus names for labeling select(-genus_order) # Calculate plot height dynamically based on number of microsamples included in this plot num_microsamples &lt;- filtered_data %&gt;% count(microsample) #print(nrow(num_microsamples)) plot_height &lt;- 5 + (nrow(num_microsamples) * 0.2) # Calculate total abundance for each genus across all phyla genus_abundance &lt;- filtered_data %&gt;% group_by(genus) %&gt;% summarise(total_abundance = sum(count, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(total_abundance)) # Get the top &#39;n&#39; genera by overall abundance top_genera &lt;- genus_abundance %&gt;% slice_head(n = top_n) %&gt;% pull(genus) filtered_data &lt;- filtered_data %&gt;% mutate( cleaned_genus = sub(&quot;^g__&quot;, &quot;&quot;, genus), # Remove g_ prefix from genus for display cleaned_phylum = sub(&quot;^p__&quot;, &quot;&quot;, phylum), # Remove p_ prefix from phylum for display genus_color = ifelse(genus %in% top_genera, as.character(phylum), &quot;Other&quot;), # Use original phylum for color mapping genus_label = ifelse(genus %in% top_genera, paste(cleaned_genus, &quot;(&quot;, cleaned_phylum, &quot;)&quot;), &quot;Other&quot;) # Use cleaned genus and phylum for labeling ) # Reorder &#39;genus_label&#39; factor by genus abundance, using cleaned phylum names for display filtered_data &lt;- filtered_data %&gt;% mutate(genus_label = factor( genus_label, levels = c(paste(sub(&quot;^g__&quot;, &quot;&quot;, top_genera), &quot;(&quot;, sub(&quot;^p__&quot;, &quot;&quot;, filtered_data$phylum[match(top_genera, filtered_data$genus)]), &quot;)&quot;), &quot;Other&quot;) )) # Prepare the phylum colors phylum_colors_named &lt;- phylum_colors #[-4] names(phylum_colors_named) &lt;- levels(filtered_data$phylum) # Generate color mapping for each genus within its phylum color_mapping &lt;- c() for (phylum in unique(filtered_data$phylum)) { phylum_data &lt;- filtered_data %&gt;% filter(phylum == !!phylum &amp; genus_label != &quot;Other&quot;) %&gt;% distinct(genus_label) n_genera &lt;- nrow(phylum_data) phylum_color &lt;- phylum_colors_named[phylum] if (n_genera &gt; 0) { # Generate shades for each genus phylum_shades &lt;- generate_shades(phylum_color, n_genera) names(phylum_shades) &lt;- phylum_data$genus_label color_mapping &lt;- c(color_mapping, phylum_shades) } } # Add grey color for &#39;Other&#39; category color_mapping[&quot;Other&quot;] &lt;- &quot;grey&quot; # Generate the plot p &lt;- ggplot(filtered_data, aes(x = count, y = microsample, fill = genus_label, group = interaction(phylum, genus_for_plot))) + geom_bar(stat = &quot;identity&quot;, colour = &quot;white&quot;, linewidth = 0.05) + # Stacked bars with white borders scale_fill_manual(values = color_mapping, drop = FALSE) + # Use manual color scale labs( x = &quot;Bacterial composition&quot;, y = &quot;Microsamples&quot;, fill = &quot;Genus (Phylum)&quot;, title = plot_params$plot_title ) + facet_nested(as.formula(plot_params$facet_formula), scales = &quot;free&quot;, space = &quot;free&quot;) + # Dynamic faceting guides(fill = guide_legend(ncol = 1)) + custom_ggplot_theme return(list(plot = p, height = plot_height)) } 4.2.3 Composition plotting function To plot figures for all the experiments. Parameters for each experiment set in the previous chapter. generate_and_save_plots &lt;- function(taxonomy_dataset, plot_base_name, plot_params_list, plot_function, filter_quality = NULL, filter_type = NULL) { # Initialize a list to store the plots plots_list &lt;- list() # Loop through each set of plot parameters and generate plots for (param_name in names(plot_params_list)) { plot_params &lt;- plot_params_list[[param_name]] # Call the plotting function dynamically result &lt;- plot_function( taxonomy_data = taxonomy_dataset, plot_params = plot_params, filter_quality = filter_quality, # Pass quality filter filter_type = filter_type # Pass type filter ) # Extract the plot and the dynamic height plot &lt;- result$plot plot_height &lt;- result$height # Store the plot in the list plots_list[[param_name]] &lt;- plot # Print the plot print(plot) # Save the plot as an image file ggsave( filename = paste0(&quot;results/figures/taxonomy/&quot;, plot_base_name, param_name, &quot;.jpg&quot;), plot = plot, device = &quot;jpg&quot;, width = 30, height = plot_height, units = &quot;cm&quot;, dpi = 300, limitsize = FALSE ) } # Return the list of plots return(plots_list) } 4.2.4 Generate taxonomy datasets Filtered data (30% coverage). taxonomy_dataset_filt &lt;- prepare_taxonomy_dataset( genome_counts_df = genome_counts_filt, genome_metadata = genome_metadata, sample_metadata = sample_metadata, quality = quality ) #print(taxonomy_dataset_filt) Unfiltered data. taxonomy_dataset_unfilt &lt;- prepare_taxonomy_dataset( genome_counts_df = genome_counts, genome_metadata = genome_metadata, sample_metadata = sample_metadata, quality = quality ) #print(taxonomy_dataset_unfilt) 4.2.5 Generate plots Filtered data, phylum level. plots &lt;- generate_and_save_plots( taxonomy_dataset = taxonomy_dataset_filt, plot_base_name = &quot;tax_filt_phyla_&quot;, plot_params_list = plot_params_list, plot_function = plot_taxonomy_data, filter_quality = 5, filter_type = c(&quot;Positive&quot;) ) Filtered data, genus level. plots &lt;- generate_and_save_plots( taxonomy_dataset = taxonomy_dataset_filt, plot_base_name = &quot;tax_filt_genus_&quot;, plot_params_list = plot_params_list, plot_function = genus_plot_taxonomy_data, filter_quality = 5, filter_type = c(&quot;Positive&quot;) ) Unfiltered data, phylum level. plots &lt;- generate_and_save_plots( taxonomy_dataset = taxonomy_dataset_unfilt, plot_base_name = &quot;tax_unfilt_phyla_&quot;, plot_params_list = plot_params_list, plot_function = plot_taxonomy_data, filter_quality = NULL, filter_type = NULL ) Unfiltered data, genus level. plots &lt;- generate_and_save_plots( taxonomy_dataset = taxonomy_dataset_unfilt, plot_base_name = &quot;tax_unfilt_genus_&quot;, plot_params_list = plot_params_list, plot_function = genus_plot_taxonomy_data, filter_quality = NULL, filter_type = NULL ) 4.3 Phylogeny &amp; MAG heatmap visualisation 4.3.1 Define MAG overview plotting fuction Visualise a phylogenetic tree from the already made ‘genome_tree’ (bioinformatics pipeline). Colour the tips (genomes) by phylum. vertical_tree &lt;- force.ultrametric(genome_tree, method = &quot;extend&quot;) %&gt;% ggtree(., size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** phylum_colors_2 &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;, show_col_types = FALSE) %&gt;% right_join(genome_metadata, by = join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% select(phylum) colors_alphabetic &lt;- read_tsv(&quot;https://raw.githubusercontent.com/earthhologenome/EHI_taxonomy_colour/main/ehi_phylum_colors.tsv&quot;, show_col_types = FALSE) %&gt;% right_join(genome_metadata, by = join_by(phylum == phylum)) %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(phylum, colors) %&gt;% unique() %&gt;% arrange(phylum) %&gt;% select(colors) %&gt;% pull() vertical_tree &lt;- gheatmap(vertical_tree, phylum_colors_2, offset = -0.3, width = 0.1, colnames = FALSE) + scale_fill_manual(values = colors_alphabetic) + new_scale_fill() Plot a heatmap next to the already created tree. NB!Here we do not filter for genomes that are 0 or NA across all samples in the current dataset, as the number of tips on the tree is set. NB! Faceting does not work with gheatmap. We need to order the samples in a way that makes sence in the heatmap. NB! We get two ‘value’ scalebars - need to remove one. plot_tree_heaatmap &lt;- function(counts, plot_base_name, plot_params_list, filter_type = NULL) { # Initialize a list to store the plots plots_list &lt;- list() # Loop through each set of plot parameters and generate plots for (param_name in names(plot_params_list)) { plot_params &lt;- plot_params_list[[param_name]] # Apply filters based on plot_params sample_selection &lt;- sample_metadata # Dynamically apply filter conditions if (length(plot_params$filter_conditions) &gt; 0) { sample_selection &lt;- sample_selection %&gt;% filter(!!!plot_params$filter_conditions) } # Dynamically apply the type filter (positive/negative) if provided if (!is.null(filter_type)) { sample_selection &lt;- sample_selection %&gt;% filter(type %in% filter_type) } valid_samples &lt;- intersect(sample_selection$microsample, colnames(counts)) genome_counts_selected &lt;- counts %&gt;% select(all_of(c(&quot;genome&quot;, valid_samples))) %&gt;% column_to_rownames(var = &quot;genome&quot;) %&gt;% tss() vertical_tree_output &lt;- gheatmap(vertical_tree, genome_counts_selected, offset = -0.1, width = 0.7, colnames = TRUE, colnames_angle = 90, font.size = 0.2, colnames_position = &quot;top&quot;, colnames_offset_y = 5) + vexpand(.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;#315b7d&quot;, na.value = &quot;white&quot;) + labs(x = &#39;relative_abundance&#39;, title = plot_params$plot_title ) # Store the plot in the list plots_list[[param_name]] &lt;- vertical_tree_output # Print the plot print(vertical_tree_output) # Save the plot as an image file ggsave( filename = paste0(&quot;results/figures/tree_heatmaps/&quot;, plot_base_name, param_name, &quot;.jpg&quot;), plot = vertical_tree_output, device = &quot;jpg&quot;, width = 30, height = 30, units = &quot;cm&quot;, dpi = 300, limitsize = FALSE ) } # Return the list of plots return(plots_list) } 4.3.2 Generate MAG tree &amp; relative abundance plots Filtered data, only positive samples. plots &lt;- plot_tree_heaatmap( counts = genome_counts_filt, plot_base_name = &quot;tree_heatmap_filt_positive_&quot;, plot_params_list = plot_params_list, filter_type = c(&quot;Positive&quot;) ) Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Unfiltered data, only positive samples. plots &lt;- plot_tree_heaatmap( counts = genome_counts, plot_base_name = &quot;tree_heatmap_unfilt_positive_&quot;, plot_params_list = plot_params_list, filter_type = c(&quot;Positive&quot;) ) Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Unfiltered data, only negative samples. plots &lt;- plot_tree_heaatmap( counts = genome_counts, plot_base_name = &quot;tree_heatmap_unfilt_negative_&quot;, plot_params_list = plot_params_list[1:7], # 1:7 because the rest do not include negatives filter_type = c(&quot;NegativeMembrane&quot;, &quot;NegativeCollection&quot;, &quot;NegativeReaction&quot;) ) Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. Scale for fill is already present. Adding another scale for fill, which will replace the existing scale. 4.4 Composition jitterplot functions plot_jitterplot &lt;- function(taxonomy_data, plot_base_name, plot_params_list, taxon_level, filter_type = NULL) { # Initialize a list to store the plots plots_list &lt;- list() # Loop through each set of plot parameters and generate plots for (param_name in names(plot_params_list)) { plot_params &lt;- plot_params_list[[param_name]] # Apply filters based on plot_params filtered_data &lt;- taxonomy_data # Dynamically apply filter conditions1 if (length(plot_params$filter_conditions) &gt; 0) { filtered_data &lt;- filtered_data %&gt;% filter(!!!plot_params$filter_conditions) } # Dynamically apply the type filter (positive/negative) if provided if (!is.null(filter_type)) { filtered_data &lt;- filtered_data %&gt;% filter(type %in% filter_type) } # Conditionally apply factor() for size based on the presence of &#39;size&#39; in plot_params$fill_var if (grepl(&quot;size&quot;, plot_params$fill_var)) { filtered_data &lt;- filtered_data %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) } # Apply special processing if taxon_level is genus if (taxon_level == &quot;genus&quot;) { filtered_data &lt;- filtered_data %&gt;% filter(genus != &quot;g__&quot;) %&gt;% # Filter out &quot;g__&quot; genus mutate(genus = sub(&quot;^g__&quot;, &quot;&quot;, genus)) # Remove the &quot;g__&quot; prefix } summary &lt;- filtered_data %&gt;% group_by(!!sym(taxon_level)) %&gt;% summarise(mean = geometric.mean(count, na.rm = T)) %&gt;% #geometric mean because it is a % arrange(-mean) plot_data &lt;- filtered_data %&gt;% mutate(!!sym(taxon_level) := factor(!!sym(taxon_level), levels = rev(summary %&gt;% pull(!!sym(taxon_level))))) new_facet_formula &lt;- gsub(&quot;(.*) ~ (.*)&quot;, &quot;\\\\2 ~ \\\\1&quot;, plot_params$facet_formula) plot &lt;- plot_data %&gt;% ggplot(aes(x = count, y = !!sym(taxon_level), group = !!sym(taxon_level), color = phylum)) + scale_color_manual(values = phylum_colors) + geom_jitter(alpha = 0.3, size=0.5) + facet_nested(as.formula(new_facet_formula)) + theme_minimal() + labs(y = &quot;Family&quot;, x = &quot;Relative abundance&quot;, color = &quot;Phylum&quot;, title = plot_params$plot_title)+ custom_ggplot_theme # Store the plot in the list plots_list[[param_name]] &lt;- plot # Print the plot print(plot) # Save the plot as an image file ggsave( filename = paste0(&quot;results/figures/composition_jitterplots/&quot;, plot_base_name, param_name, &quot;.jpg&quot;), plot = plot, device = &quot;jpg&quot;, width = 30, height = 30, units = &quot;cm&quot;, dpi = 300, limitsize = FALSE ) } # Return the list of plots return(plots_list) } Coverage filtered, positive samples, genome level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_filt, plot_base_name = &quot;jitterplot_filt_genome_positive_&quot;, plot_params_list = plot_params_list, taxon_level = &#39;genome&#39;, filter_type = c(&quot;Positive&quot;) ) Coverage filtered, positive samples, genus level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_filt, plot_base_name = &quot;jitterplot_filt_genus_positive_&quot;, plot_params_list = plot_params_list, taxon_level = &#39;genus&#39;, filter_type = c(&quot;Positive&quot;) ) Not-filtered, positive samples, genome level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_unfilt, plot_base_name = &quot;jitterplot_unfilt_genome_positive_&quot;, plot_params_list = plot_params_list, taxon_level = &#39;genome&#39;, filter_type = c(&quot;Positive&quot;) ) Not-filtered, positive samples, genus level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_unfilt, plot_base_name = &quot;jitterplot_unfilt_genus_positive_&quot;, plot_params_list = plot_params_list, taxon_level = &#39;genus&#39;, filter_type = c(&quot;Positive&quot;) ) Not-filtered, negative controls, genome level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_unfilt, plot_base_name = &quot;jitterplot_unfilt_genome_negative_&quot;, plot_params_list = plot_params_list[1:7], # 1:7 because the rest do not include negatives taxon_level = &#39;genome&#39;, filter_type = c(&quot;NegativeMembrane&quot;, &quot;NegativeCollection&quot;, &quot;NegativeReaction&quot;) ) Not-filtered, negative controls, genus level plots &lt;- plot_jitterplot( taxonomy_data = taxonomy_dataset_unfilt, plot_base_name = &quot;jitterplot_unfilt_genus_negative_&quot;, plot_params_list = plot_params_list[1:7], # 1:7 because the rest do not include negatives taxon_level = &#39;genus&#39;, filter_type = c(&quot;NegativeMembrane&quot;, &quot;NegativeCollection&quot;, &quot;NegativeReaction&quot;) ) 4.5 Covariance NB! This is not compositional and must be checked with compositional math too. taxon_level &lt;- &quot;genus&quot; taxon_list &lt;- c(&quot;g__Lactobacillus&quot;, &quot;g__Escherichia&quot;, &quot;g__Streptococcus&quot;, &quot;g__Eisenbergiella&quot;, &quot;g__Mediterraneibacter&quot;, &quot;g__Caccovicinus&quot;) genus_summary &lt;- genome_counts_filt %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% # apply TSS nornalisation pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% # reduce to minimum number of columns left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% # append sample metadata left_join(quality, by = join_by(microsample == microsample)) %&gt;% filter(quality &gt;= 5) %&gt;% left_join(., genome_metadata, by = join_by(genome == genome)) %&gt;% # append genome metadata group_by(microsample, cryosection, !!sym(taxon_level)) %&gt;% summarise(relabun = sum(count)) genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Caccovicinus&quot;, &quot;g__Streptococcus&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Caccovicinus, y = g__Streptococcus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Lactobacillus&quot;, &quot;g__Streptococcus&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Lactobacillus, y = g__Streptococcus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Lactobacillus&quot;, &quot;g__Mediterraneibacter&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Mediterraneibacter, y = g__Lactobacillus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Streptococcus&quot;, &quot;g__Mediterraneibacter&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Streptococcus, y = g__Mediterraneibacter)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Lactobacillus&quot;, &quot;g__Caccovicinus&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Caccovicinus, y = g__Lactobacillus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Lactobacillus&quot;, &quot;g__Escherichia&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Escherichia, y = g__Lactobacillus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() genus_summary %&gt;% mutate(individual = substr(cryosection, 1, 4)) %&gt;% filter(genus %in% c(&quot;g__Streptococcus&quot;, &quot;g__Caccovicinus&quot;)) %&gt;% pivot_wider(names_from = genus, values_from = relabun) %&gt;% ggplot(aes(x = g__Streptococcus, y = g__Caccovicinus)) + geom_point() + geom_smooth(method = lm, color = &quot;red&quot;, fill = &quot;#69b3a2&quot;, se = TRUE) + facet_grid(~individual) + theme_minimal() "],["alpha-diversity.html", "Chapter 5 Alpha diversity 5.1 Load data", " Chapter 5 Alpha diversity 5.1 Load data Load the data produced in the 2nd chapter load(&quot;data/data.Rdata&quot;) quality &lt;- read_tsv(&quot;results/final_combined_stats.tsv&quot;, col_types = cols_only(microsample = col_character(), quality = col_double()), show_col_types = FALSE ) Define function to estimate alpha diversity measurements. calculate_alpha_diversity &lt;- function(input_data, dataset_name) { # Step 1: Transform the input data (remove rownames if needed) input_data_matrix &lt;- input_data %&gt;% column_to_rownames(var = &quot;genome&quot;) # Step 2: Calculate richness (q = 0) richness &lt;- hilldiv(input_data_matrix, q = 0) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(richness = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 3: Calculate neutral diversity (q = 1) neutral &lt;- hilldiv(input_data_matrix, q = 1) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(neutral = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 4: Calculate phylogenetic diversity (q = 1, with genome tree) phylogenetic &lt;- hilldiv(input_data_matrix, q = 1, tree = genome_tree) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(phylogenetic = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 5: Merge all diversity metrics alpha_diversity &lt;- richness %&gt;% full_join(neutral, by = &quot;microsample&quot;) %&gt;% full_join(phylogenetic, by = &quot;microsample&quot;) %&gt;% left_join(sample_metadata, by = &quot;microsample&quot;) # Step 6: Define the output file name based on the dataset name output_filename &lt;- paste0(&quot;results/alpha_div_&quot;, dataset_name, &quot;.tsv&quot;) # Step 7: Write the result to a tsv file alpha_diversity %&gt;% write_tsv(output_filename) # Return the alpha_diversity data frame return(alpha_diversity) } Estimate the alpha diversity on the unfiltered and the coverage-filtered counts # Calculate alpha diversity for filtered genome counts data alpha_div_filtered &lt;- calculate_alpha_diversity( input_data = genome_counts_filt, dataset_name = &quot;filtered&quot; ) # Calculate alpha diversity for unfiltered genome counts data alpha_div_unfiltered &lt;- calculate_alpha_diversity( input_data = genome_counts, dataset_name = &quot;unfiltered&quot; ) plot_alpha_diversity &lt;- function(alpha_div_dataset, plot_base_name, plot_params_list, filter_type = NULL) { # Initialize a list to store the plots plots_list &lt;- list() # Loop through each set of plot parameters and generate plots for (param_name in names(plot_params_list)) { plot_params &lt;- plot_params_list[[param_name]] # Apply filters based on plot_params and filter_type if provided filtered_data &lt;- alpha_div_dataset # Dynamically apply filter conditions1 if (length(plot_params$filter_conditions) &gt; 0) { filtered_data &lt;- filtered_data %&gt;% filter(!!!plot_params$filter_conditions) } # Dynamically apply the type filter (positive/negative) if provided if (!is.null(filter_type)) { filtered_data &lt;- filtered_data %&gt;% filter(type %in% filter_type) } # Conditionally apply factor() for size based on the presence of &#39;size&#39; in plot_params$fill_var if (grepl(&quot;size&quot;, plot_params$fill_var)) { filtered_data &lt;- filtered_data %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000))) } # Pivot the relevant columns for diversity metrics filtered_data &lt;- filtered_data %&gt;% pivot_longer( cols = c(richness, neutral, phylogenetic), names_to = &quot;metric&quot;, values_to = &quot;value&quot; ) %&gt;% left_join(quality, by = join_by(microsample == microsample)) %&gt;% mutate(metric = factor(metric, levels = c(&quot;richness&quot;, &quot;neutral&quot;, &quot;phylogenetic&quot;))) %&gt;% filter(!is.na(value)) # Filter out rows with NA values in the value column new_facet_formula &lt;- gsub(&quot;(.*) ~ \\\\.&quot;, &quot;metric ~ \\\\1&quot;, plot_params$facet_formula) # Create the plot plot &lt;- ggplot(filtered_data, aes(x = plot_params$fill_var, y = value, color = quality)) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;Quality&quot;, limits = c(0, 5)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2) + facet_nested(as.formula(new_facet_formula), scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + labs( title = plot_params$plot_title, x = stat_params$fill_var ) # Store the plot in the list plots_list[[param_name]] &lt;- plot # Print the plot print(plot) # Save the plot as an image file ggsave( filename = paste0(&quot;results/figures/alpha_diversity_plots/&quot;, plot_base_name, param_name, &quot;.jpg&quot;), plot = plot, device = &quot;jpg&quot;, width = 30, height = 30, units = &quot;cm&quot;, dpi = 300, limitsize = FALSE ) } # Return the list of plots return(plots_list) } Coverage-filtered data, positive samples alpha_div_plots &lt;- plot_alpha_diversity( alpha_div_dataset = alpha_div_filtered, plot_base_name = &quot;alpha_div_filt_pos_&quot;, plot_params_list = plot_params_list, filter_type = c(&quot;Positive&quot;) ) Coverage-filtered data, all samples alpha_div_plots &lt;- plot_alpha_diversity( alpha_div_dataset = alpha_div_filtered, plot_base_name = &quot;alpha_div_filt_all_&quot;, plot_params_list = plot_params_list, filter_type = NULL ) Unfiltered data, positive samples alpha_div_plots &lt;- plot_alpha_diversity( alpha_div_dataset = alpha_div_unfiltered, plot_base_name = &quot;alpha_div_unfilt_pos_&quot;, plot_params_list = plot_params_list, filter_type = c(&quot;Positive&quot;) ) Unfiltered data, all samples alpha_div_plots &lt;- plot_alpha_diversity( alpha_div_dataset = alpha_div_unfiltered, plot_base_name = &quot;alpha_div_unfilt_all_&quot;, plot_params_list = plot_params_list, filter_type = NULL ) "],["beta-diversity.html", "Chapter 6 Beta diversity 6.1 NMDS plots", " Chapter 6 Beta diversity load(&quot;data/data.Rdata&quot;) quality &lt;- read_tsv(&quot;results/final_combined_stats.tsv&quot;, col_types = cols_only(microsample = col_character(), quality = col_double()), show_col_types = FALSE ) 6.1 NMDS plots # selected_samples &lt;- sample_metadata %&gt;% # filter(section != &quot;Ileum&quot;) %&gt;% # filter(section != &quot;Colon&quot;) %&gt;% # filter(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) %&gt;% # filter(type == &quot;Positive&quot;) %&gt;% # filter(microsample %in% colnames(genome_counts_filt)) %&gt;% # filter(!is.na(Xcoord)) %&gt;% # select(microsample) %&gt;% pull() # # #Calculate Hill numbers # richness_caecum &lt;- genome_counts_filt %&gt;% # column_to_rownames(var=&quot;genome&quot;) %&gt;% # select(all_of(selected_samples)) %&gt;% # select(where(~!all(. == 0))) %&gt;% # hillpair(.,q=0, metric=&quot;C&quot;, out=&quot;pair&quot;) # # neutral_caecum &lt;- genome_counts_filt %&gt;% # column_to_rownames(var=&quot;genome&quot;) %&gt;% # select(all_of(selected_samples)) %&gt;% # select(where(~!all(. == 0))) %&gt;% # hillpair(.,q=1, metric=&quot;C&quot;, out=&quot;pair&quot;) # # phylogenetic_caecum &lt;- genome_counts_filt %&gt;% # column_to_rownames(var=&quot;genome&quot;) %&gt;% # select(all_of(selected_samples)) %&gt;% # select(where(~!all(. == 0))) %&gt;% # hillpair(.,q=1, tree=genome_tree, metric=&quot;C&quot;, out=&quot;pair&quot;) # # # Merge beta diversities # beta_diversity &lt;- richness_caecum %&gt;% # full_join(neutral_caecum,by=c(&quot;first&quot;, &quot;second&quot;)) %&gt;% # full_join(phylogenetic_caecum,by=c(&quot;first&quot;, &quot;second&quot;)) %&gt;% # rename(richness=C.x, neutral=C.y, phylogenetic=C) # # # Write alpha diversities # beta_diversity %&gt;% write_tsv(&quot;results/beta_div.tsv&quot;) # beta_diversity &lt;- read_tsv(&quot;results/beta_div.tsv&quot;) # # # # Select high-quality samples # # caecum_samples_hq &lt;- sample_metadata %&gt;% # # left_join(quality,by=join_by(microsample==microsample)) %&gt;% # # filter(quality &gt;= 5) %&gt;% # # filter(!is.na(Xcoord)) %&gt;% # # select(microsample) %&gt;% # # pull() # # caecum_samples_hq &lt;- sample_metadata %&gt;% # filter(section != &quot;Ileum&quot;) %&gt;% # filter(section != &quot;Colon&quot;) %&gt;% # filter(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) %&gt;% # filter(type == &quot;Positive&quot;) %&gt;% # filter(!is.na(Xcoord)) %&gt;% # select(microsample) %&gt;% # pull() Adult vs young animal selected_samples &lt;- sample_metadata %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% filter(section != &quot;Colon&quot;) %&gt;% filter(batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% filter(microsample %in% colnames(genome_counts_filt)) %&gt;% filter(!is.na(Xcoord)) %&gt;% select(microsample) %&gt;% pull() samples_nmds &lt;- genome_counts_filt %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(all_of(selected_samples)) %&gt;% select(where(~!all(. == 0))) %&gt;% hillpair(.,q=1, metric=&quot;C&quot;, out=&quot;dist&quot;) %&gt;% metaMDS(.,trymax = 999, k=2, trace=0) %&gt;% vegan::scores() %&gt;% as_tibble(., rownames = &quot;microsample&quot;) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% group_by(cryosection) %&gt;% mutate(microsample_x=mean(NMDS1), microsample_y=mean(NMDS2)) plot1 &lt;- samples_nmds %&gt;% ggplot(aes(x=NMDS1,y=NMDS2, color=animal)) + geom_point(size=2) + geom_segment(aes(x=microsample_x, y=microsample_y, xend=NMDS1, yend=NMDS2), alpha=0.2) + scale_color_manual(values=c(&#39;#ffc273&#39;,&#39;#c1558b&#39;)) + #&quot;#a3d1cf&quot;,&quot;#d1a3cf&quot;, theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Animal&quot;)) print(plot1) Ceacum vs colon (of adult) selected_samples &lt;- sample_metadata %&gt;% filter(section != &quot;Ileum&quot;) %&gt;% filter(animal == &#39;G121e&#39;) %&gt;% filter(cycles&lt;16) %&gt;% filter(batch == &quot;MSEB0009&quot;|batch == &quot;MSEB0010&quot;|batch == &quot;MSEB0011&quot;|batch == &quot;MSEB0012&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% filter(microsample %in% colnames(genome_counts_filt)) %&gt;% filter(!is.na(Xcoord)) %&gt;% select(microsample) %&gt;% pull() samples_nmds &lt;- genome_counts_filt %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(all_of(selected_samples)) %&gt;% select(where(~!all(. == 0))) %&gt;% hillpair(.,q=1, metric=&quot;C&quot;, out=&quot;dist&quot;) %&gt;% metaMDS(.,trymax = 999, k=2, trace=0) %&gt;% vegan::scores() %&gt;% as_tibble(., rownames = &quot;microsample&quot;) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% group_by(cryosection) %&gt;% mutate(microsample_x=mean(NMDS1), microsample_y=mean(NMDS2)) plot2 &lt;- samples_nmds %&gt;% ggplot(aes(x=NMDS1,y=NMDS2, color=section)) + geom_point(size=2) + geom_segment(aes(x=microsample_x, y=microsample_y, xend=NMDS1, yend=NMDS2), alpha=0.2) + scale_color_manual(values=c(&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;)) + #&quot;#a3d1cf&quot;,&quot;#d1a3cf&quot;, theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Section&quot;)) print(plot2) Different LMD sizes selected_samples &lt;- sample_metadata %&gt;% filter(batch == &quot;MSEB0014&quot;) %&gt;% filter(type == &quot;Positive&quot;) %&gt;% filter(microsample %in% colnames(genome_counts_filt)) %&gt;% filter(!is.na(Xcoord)) %&gt;% select(microsample) %&gt;% pull() samples_nmds &lt;- genome_counts_filt %&gt;% column_to_rownames(var=&quot;genome&quot;) %&gt;% select(all_of(selected_samples)) %&gt;% select(where(~!all(. == 0))) %&gt;% hillpair(.,q=1, metric=&quot;C&quot;, out=&quot;dist&quot;) %&gt;% metaMDS(.,trymax = 999, k=2, trace=0) %&gt;% vegan::scores() %&gt;% as_tibble(., rownames = &quot;microsample&quot;) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% group_by(size) %&gt;% mutate(microsample_x=mean(NMDS1), microsample_y=mean(NMDS2)) plot3 &lt;- samples_nmds %&gt;% mutate(size = factor(size, levels = c(500, 1500, 2500, 5000, 25000, 50000)))%&gt;% ggplot(aes(x=NMDS1,y=NMDS2, color=size)) + geom_point(size=2) + geom_segment(aes(x=microsample_x, y=microsample_y, xend=NMDS1, yend=NMDS2), alpha=0.2) + scale_color_manual(values=c(&#39;#ffdf9e&#39;,&#39;#ffc273&#39;,&#39;#e56969&#39;,&#39;#c1558b&#39;,&#39;#8a49a1&#39;,&#39;#4f5bd5&#39;)) + #&quot;#a3d1cf&quot;,&quot;#d1a3cf&quot;, theme_classic() + theme(legend.position=&quot;right&quot;, legend.box=&quot;vertical&quot;) + guides(color=guide_legend(title=&quot;Size&quot;)) print(plot3) 6.1.1 Compositional # NOT READY "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
